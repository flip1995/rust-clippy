[
  {
    "id": "approx_constant",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for floating point literals that approximate\nconstants which are defined in\n[`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants)\nor\n[`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants),\nrespectively, suggesting to use the predefined constant.",
      "Why is this bad": "Usually, the definition in the standard library is more\nprecise than what people come up with. If you find that your definition is\nactually more precise, please [file a Rust\nissue](https://github.com/rust-lang/rust/issues).",
      "Known problems": "None.",
      "Example": "```rust\nlet x = 3.14;\n```"
    }
  },
  {
    "id": "integer_arithmetic",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for plain integer arithmetic.",
      "Why is this bad": "This is only checked against overflow in debug builds.\nIn some applications one wants explicitly checked, wrapping or saturating\narithmetic.",
      "Known problems": "None.",
      "Example": "```rust\na + 1\n```"
    }
  },
  {
    "id": "float_arithmetic",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for float arithmetic.",
      "Why is this bad": "For some embedded systems or kernel development, it\ncan be useful to rule out floating-point numbers.",
      "Known problems": "None.",
      "Example": "```rust\na + 1.0\n```"
    }
  },
  {
    "id": "assertions_on_constants",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for `assert!(true)` and `assert!(false)` calls.",
      "Why is this bad": "Will be optimized out by the compiler or should probably be replaced by a\npanic!() or unreachable!()",
      "Known problems": "None",
      "Example": "```rust,ignore\nassert!(false)\n// or\nassert!(true)\n// or\nconst B: bool = false;\nassert!(B)\n```"
    }
  },
  {
    "id": "assign_op_pattern",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for `a = a op b` or `a = b commutative_op a`\npatterns.",
      "Why is this bad": "These can be written as the shorter `a op= b`.",
      "Known problems": "While forbidden by the spec, `OpAssign` traits may have\nimplementations that differ from the regular `Op` impl.",
      "Example": "```rust\nlet mut a = 5;\nlet b = 0;\n// ...\na = a + b;\n```"
    }
  },
  {
    "id": "misrefactored_assign_op",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for `a op= a op b` or `a op= b op a` patterns.",
      "Why is this bad": "Most likely these are bugs where one meant to write `a\nop= b`.",
      "Known problems": "Clippy cannot know for sure if `a op= a op b` should have\nbeen `a = a op a op b` or `a = a op b`/`a op= b`. Therefore, it suggests both.\nIf `a op= a op b` is really the correct behaviour it should be\nwritten as `a = a op a op b` as it's less confusing.",
      "Example": "```rust\nlet mut a = 5;\n...\na += a + b;\n```"
    }
  },
  {
    "id": "inline_always",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for items annotated with `#[inline(always)]`,\nunless the annotated function is empty or simply panics.",
      "Why is this bad": "While there are valid uses of this annotation (and once\nyou know when to use it, by all means `allow` this lint), it's a common\nnewbie-mistake to pepper one's code with it.\nAs a rule of thumb, before slapping `#[inline(always)]` on a function,\nmeasure if that additional function call really affects your runtime profile\nsufficiently to make up for the increase in compile time.",
      "Known problems": "False positives, big time. This lint is meant to be\ndeactivated by everyone doing serious performance work. This means having\ndone the measurement.",
      "Example": "```ignore\n#[inline(always)]\nfn not_quite_hot_code(..) { ... }\n```"
    }
  },
  {
    "id": "useless_attribute",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for `extern crate` and `use` items annotated with\nlint attributes.\nThis lint whitelists `#[allow(unused_imports)]`, `#[allow(deprecated)]` and\n`#[allow(unreachable_pub)]` on `use` items and `#[allow(unused_imports)]` on\n`extern crate` items with a `#[macro_use]` attribute.",
      "Why is this bad": "Lint attributes have no effect on crate imports. Most\nlikely a `!` was forgotten.",
      "Known problems": "None.",
      "Example": "```ignore\n// Bad\n#[deny(dead_code)]\nextern crate foo;\n#[forbid(dead_code)]\nuse foo::bar;\n// Ok\n#[allow(unused_imports)]\nuse foo::baz;\n#[allow(unused_imports)]\n#[macro_use]\nextern crate baz;\n```"
    }
  },
  {
    "id": "deprecated_semver",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for `#[deprecated]` annotations with a `since`\nfield that is not a valid semantic version.",
      "Why is this bad": "For checking the version of the deprecation, it must be\na valid semver. Failing that, the contained information is useless.",
      "Known problems": "None.",
      "Example": "```rust\n#[deprecated(since = \"forever\")]\nfn something_else() { /* ... */ }\n```"
    }
  },
  {
    "id": "empty_line_after_outer_attr",
    "group": "nursery",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for empty lines after outer attributes",
      "Why is this bad": "Most likely the attribute was meant to be an inner attribute using a '!'.\nIf it was meant to be an outer attribute, then the following item\nshould not be separated by empty lines.",
      "Known problems": "Can cause false positives.\nFrom the clippy side it's difficult to detect empty lines between an attributes and the\nfollowing item because empty lines and comments are not part of the AST. The parsing\ncurrently works for basic cases but is not perfect.",
      "Example": "```rust\n// Bad\n#[inline(always)]\nfn not_quite_good_code(..) { ... }\n// Good (as inner attribute)\n#![inline(always)]\nfn this_is_fine(..) { ... }\n// Good (as outer attribute)\n#[inline(always)]\nfn this_is_fine_too(..) { ... }\n```"
    }
  },
  {
    "id": "unknown_clippy_lints",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for `allow`/`warn`/`deny`/`forbid` attributes with scoped clippy\nlints and if those lints exist in clippy. If there is an uppercase letter in the lint name\n(not the tool name) and a lowercase version of this lint exists, it will suggest to lowercase\nthe lint name.",
      "Why is this bad": "A lint attribute with a mistyped lint name won't have an effect.",
      "Known problems": "None.",
      "Example": "Bad:\n```rust\n#![warn(if_not_els)]\n#![deny(clippy::All)]\n```\nGood:\n```rust\n#![warn(if_not_else)]\n#![deny(clippy::all)]\n```"
    }
  },
  {
    "id": "deprecated_cfg_attr",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for `#[cfg_attr(rustfmt, rustfmt_skip)]` and suggests to replace it\nwith `#[rustfmt::skip]`.",
      "Why is this bad": "Since tool_attributes ([rust-lang/rust#44690](https://github.com/rust-lang/rust/issues/44690))\nare stable now, they should be used instead of the old `cfg_attr(rustfmt)` attributes.",
      "Known problems": "This lint doesn't detect crate level inner attributes, because they get\nprocessed before the PreExpansionPass lints get executed. See\n[#3123](https://github.com/rust-lang/rust-clippy/pull/3123#issuecomment-422321765)",
      "Example": "Bad:\n```rust\n#[cfg_attr(rustfmt, rustfmt_skip)]\nfn main() { }\n```\nGood:\n```rust\n#[rustfmt::skip]\nfn main() { }\n```"
    }
  },
  {
    "id": "bad_bit_mask",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for incompatible bit masks in comparisons.\nThe formula for detecting if an expression of the type `_ <bit_op> m\n<cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n{`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\ntable:\n|Comparison  |Bit Op|Example     |is always|Formula               |\n|------------|------|------------|---------|----------------------|\n|`==` or `!=`| `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n|`<`  or `>=`| `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n|`>`  or `<=`| `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n|`==` or `!=`| `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n|`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n|`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |",
      "Why is this bad": "If the bits that the comparison cares about are always\nset to zero or one by the bit mask, the comparison is constant `true` or\n`false` (depending on mask, compared value, and operators).\nSo the code is actively misleading, and the only reason someone would write\nthis intentionally is to win an underhanded Rust contest or create a\ntest-case for this lint.",
      "Known problems": "None.",
      "Example": "```rust\n# let x = 1;\nif (x & 1 == 2) { }\n```"
    }
  },
  {
    "id": "ineffective_bit_mask",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for bit masks in comparisons which can be removed\nwithout changing the outcome. The basic structure can be seen in the\nfollowing table:\n|Comparison| Bit Op  |Example    |equals |\n|----------|---------|-----------|-------|\n|`>` / `<=`|`|` / `^`|`x | 2 > 3`|`x > 3`|\n|`<` / `>=`|`|` / `^`|`x ^ 1 < 4`|`x < 4`|",
      "Why is this bad": "Not equally evil as [`bad_bit_mask`](#bad_bit_mask),\nbut still a bit misleading, because the bit mask is ineffective.",
      "Known problems": "False negatives: This lint will only match instances\nwhere we have figured out the math (which is for a power-of-two compared\nvalue). This means things like `x | 1 >= 7` (which would be better written\nas `x >= 6`) will not be reported (but bit masks like this are fairly\nuncommon).",
      "Example": "```rust\n# let x = 1;\nif (x | 1 > 3) {  }\n```"
    }
  },
  {
    "id": "verbose_bit_mask",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for bit masks that can be replaced by a call\nto `trailing_zeros`",
      "Why is this bad": "`x.trailing_zeros() > 4` is much clearer than `x & 15\n== 0`",
      "Known problems": "llvm generates better code for `x & 15 == 0` on x86",
      "Example": "```rust\n# let x = 1;\nif x & 0x1111 == 0 { }\n```",
      "Configuration": "This lint has the following configuration variables:\n\n* `verbose-bit-mask-threshold: u64`: The maximum allowed size of a bit mask before suggesting to use 'trailing_zeros' (defaults to `1 `)."
    }
  },
  {
    "id": "blacklisted_name",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of blacklisted names for variables, such\nas `foo`.",
      "Why is this bad": "These names are usually placeholder names and should be\navoided.",
      "Known problems": "None.",
      "Example": "```rust\nlet foo = 3.14;\n```",
      "Configuration": "This lint has the following configuration variables:\n\n* `blacklisted-names: Vec<String>`: The list of blacklisted names to lint about (defaults to `[\"foo\", \"bar\", \"baz\", \"quux\"] `)."
    }
  },
  {
    "id": "block_in_if_condition_expr",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for `if` conditions that use blocks to contain an\nexpression.",
      "Why is this bad": "It isn't really Rust style, same as using parentheses\nto contain expressions.",
      "Known problems": "None.",
      "Example": "```rust\nif { true } { /* ... */ }\n```"
    }
  },
  {
    "id": "block_in_if_condition_stmt",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for `if` conditions that use blocks containing\nstatements, or conditions that use closures with blocks.",
      "Why is this bad": "Using blocks in the condition makes it hard to read.",
      "Known problems": "None.",
      "Example": "```ignore\nif { let x = somefunc(); x } {}\n// or\nif somefunc(|x| { x == 47 }) {}\n```"
    }
  },
  {
    "id": "nonminimal_bool",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for boolean expressions that can be written more\nconcisely.",
      "Why is this bad": "Readability of boolean expressions suffers from\nunnecessary duplication.",
      "Known problems": "Ignores short circuiting behavior of `||` and\n`&&`. Ignores `|`, `&` and `^`.",
      "Example": "```ignore\nif a && true  // should be: if a\nif !(a == b)  // should be: if a != b\n```"
    }
  },
  {
    "id": "logic_bug",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for boolean expressions that contain terminals that\ncan be eliminated.",
      "Why is this bad": "This is most likely a logic bug.",
      "Known problems": "Ignores short circuiting behavior.",
      "Example": "```ignore\nif a && b || a { ... }\n```\nThe `b` is unnecessary, the expression is equivalent to `if a`."
    }
  },
  {
    "id": "naive_bytecount",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for naive byte counts",
      "Why is this bad": "The [`bytecount`](https://crates.io/crates/bytecount)\ncrate has methods to count your bytes faster, especially for large slices.",
      "Known problems": "If you have predominantly small slices, the\n`bytecount::count(..)` method may actually be slower. However, if you can\nensure that less than 2\u00b3\u00b2-1 matches arise, the `naive_count_32(..)` can be\nfaster in those cases.",
      "Example": "```rust\n&my_data.filter(|&x| x == 0u8).count() // use bytecount::count instead\n```"
    }
  },
  {
    "id": "cargo_common_metadata",
    "group": "cargo",
    "level": "Allow",
    "docs": {
      "What it does": "Checks to see if all common metadata is defined in\n`Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata",
      "Why is this bad": "It will be more difficult for users to discover the\npurpose of the crate, and key information related to it.",
      "Known problems": "None.",
      "Example": "```toml\n# This `Cargo.toml` is missing an authors field:\n[package]\nname = \"clippy\"\nversion = \"0.0.212\"\ndescription = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\nrepository = \"https://github.com/rust-lang/rust-clippy\"\nreadme = \"README.md\"\nlicense = \"MIT/Apache-2.0\"\nkeywords = [\"clippy\", \"lint\", \"plugin\"]\ncategories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n```"
    }
  },
  {
    "id": "checked_conversions",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for explicit bounds checking when casting.",
      "Why is this bad": "Reduces the readability of statements & is error prone.",
      "Known problems": "None.",
      "Example": "```rust\n# let foo: u32 = 5;\n# let _ =\nfoo <= i32::max_value() as u32\n# ;\n```\nCould be written:\n```rust\n# let _ =\ni32::try_from(foo).is_ok()\n# ;\n```"
    }
  },
  {
    "id": "cognitive_complexity",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for methods with high cognitive complexity.",
      "Why is this bad": "Methods of high cognitive complexity tend to be hard to\nboth read and maintain. Also LLVM will tend to optimize small methods better.",
      "Known problems": "Sometimes it's hard to find a way to reduce the\ncomplexity.",
      "Example": "No. You'll see it when you get the warning.",
      "Configuration": "This lint has the following configuration variables:\n\n* `cognitive-complexity-threshold: u64`: The maximum cognitive complexity a function can have (defaults to `25 `)."
    }
  },
  {
    "id": "collapsible_if",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for nested `if` statements which can be collapsed\nby `&&`-combining their conditions and for `else { if ... }` expressions\nthat\ncan be collapsed to `else if ...`.",
      "Why is this bad": "Each `if`-statement adds one level of nesting, which\nmakes code look more complex than it really is.",
      "Known problems": "None.",
      "Example": "```rust,ignore\nif x {\n    if y {\n        \u2026\n    }\n}\n// or\nif x {\n    \u2026\n} else {\n    if y {\n        \u2026\n    }\n}\n```\nShould be written:\n```rust.ignore\nif x && y {\n    \u2026\n}\n// or\nif x {\n    \u2026\n} else if y {\n    \u2026\n}\n```"
    }
  },
  {
    "id": "ifs_same_cond",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for consecutive `if`s with the same condition.",
      "Why is this bad": "This is probably a copy & paste error.",
      "Known problems": "Hopefully none.",
      "Example": "```ignore\nif a == b {\n    \u2026\n} else if a == b {\n    \u2026\n}\n```\nNote that this lint ignores all conditions with a function call as it could\nhave side effects:\n```ignore\nif foo() {\n    \u2026\n} else if foo() { // not linted\n    \u2026\n}\n```"
    }
  },
  {
    "id": "if_same_then_else",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for `if/else` with the same body as the *then* part\nand the *else* part.",
      "Why is this bad": "This is probably a copy & paste error.",
      "Known problems": "Hopefully none.",
      "Example": "```ignore\nlet foo = if \u2026 {\n    42\n} else {\n    42\n};\n```"
    }
  },
  {
    "id": "match_same_arms",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for `match` with identical arm bodies.",
      "Why is this bad": "This is probably a copy & paste error. If arm bodies\nare the same on purpose, you can factor them\n[using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).",
      "Known problems": "False positive possible with order dependent `match`\n(see issue\n[#860](https://github.com/rust-lang/rust-clippy/issues/860)).",
      "Example": "```rust,ignore\nmatch foo {\n    Bar => bar(),\n    Quz => quz(),\n    Baz => bar(), // <= oops\n}\n```\nThis should probably be\n```rust,ignore\nmatch foo {\n    Bar => bar(),\n    Quz => quz(),\n    Baz => baz(), // <= fixed\n}\n```\nor if the original code was not a typo:\n```rust,ignore\nmatch foo {\n    Bar | Baz => bar(), // <= shows the intent better\n    Quz => quz(),\n}\n```"
    }
  },
  {
    "id": "copy_iterator",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for types that implement `Copy` as well as\n`Iterator`.",
      "Why is this bad": "Implicit copies can be confusing when working with\niterator combinators.",
      "Known problems": "None.",
      "Example": "```rust\n#[derive(Copy, Clone)]\nstruct Countdown(u8);\nimpl Iterator for Countdown {\n    // ...\n}\nlet a: Vec<_> = my_iterator.take(1).collect();\nlet b: Vec<_> = my_iterator.collect();\n```"
    }
  },
  {
    "id": "dbg_macro",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usage of dbg!() macro.",
      "Why is this bad": "`dbg!` macro is intended as a debugging tool. It\nshould not be in version control.",
      "Known problems": "None.",
      "Example": "```rust,ignore\n// Bad\ndbg!(true)\n// Good\ntrue\n```"
    }
  },
  {
    "id": "default_trait_access",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for literal calls to `Default::default()`.",
      "Why is this bad": "It's more clear to the reader to use the name of the type whose default is\nbeing gotten than the generic `Default`.",
      "Known problems": "None.",
      "Example": "```rust\n// Bad\nlet s: String = Default::default();\n// Good\nlet s = String::default();\n```"
    }
  },
  {
    "id": "should_assert_eq",
    "group": "deprecated",
    "level": "Deprecated",
    "docs": {}
  },
  {
    "id": "extend_from_slice",
    "group": "deprecated",
    "level": "Deprecated",
    "docs": {}
  },
  {
    "id": "range_step_by_zero",
    "group": "deprecated",
    "level": "Deprecated",
    "docs": {}
  },
  {
    "id": "unstable_as_slice",
    "group": "deprecated",
    "level": "Deprecated",
    "docs": {}
  },
  {
    "id": "unstable_as_mut_slice",
    "group": "deprecated",
    "level": "Deprecated",
    "docs": {}
  },
  {
    "id": "str_to_string",
    "group": "deprecated",
    "level": "Deprecated",
    "docs": {}
  },
  {
    "id": "string_to_string",
    "group": "deprecated",
    "level": "Deprecated",
    "docs": {}
  },
  {
    "id": "misaligned_transmute",
    "group": "deprecated",
    "level": "Deprecated",
    "docs": {}
  },
  {
    "id": "assign_ops",
    "group": "deprecated",
    "level": "Deprecated",
    "docs": {}
  },
  {
    "id": "if_let_redundant_pattern_matching",
    "group": "deprecated",
    "level": "Deprecated",
    "docs": {}
  },
  {
    "id": "unsafe_vector_initialization",
    "group": "deprecated",
    "level": "Deprecated",
    "docs": {}
  },
  {
    "id": "derive_hash_xor_eq",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for deriving `Hash` but implementing `PartialEq`\nexplicitly or vice versa.",
      "Why is this bad": "The implementation of these traits must agree (for\nexample for use with `HashMap`) so it\u2019s probably a bad idea to use a\ndefault-generated `Hash` implementation with an explicitly defined\n`PartialEq`. In particular, the following must hold for any type:\n```text\nk1 == k2 \u21d2 hash(k1) == hash(k2)\n```",
      "Known problems": "None.",
      "Example": "```ignore\n#[derive(Hash)]\nstruct Foo;\nimpl PartialEq for Foo {\n    ...\n}\n```"
    }
  },
  {
    "id": "expl_impl_clone_on_copy",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for explicit `Clone` implementations for `Copy`\ntypes.",
      "Why is this bad": "To avoid surprising behaviour, these traits should\nagree and the behaviour of `Copy` cannot be overridden. In almost all\nsituations a `Copy` type should have a `Clone` implementation that does\nnothing more than copy the object, which is what `#[derive(Copy, Clone)]`\ngets you.",
      "Known problems": "Bounds of generic types are sometimes wrong: https://github.com/rust-lang/rust/issues/26925",
      "Example": "```rust\n#[derive(Copy)]\nstruct Foo;\nimpl Clone for Foo {\n    ..\n}\n```"
    }
  },
  {
    "id": "doc_markdown",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for the presence of `_`, `::` or camel-case words\noutside ticks in documentation.",
      "Why is this bad": "*Rustdoc* supports markdown formatting, `_`, `::` and\ncamel-case probably indicates some code which should be included between\nticks. `_` can also be used for emphasis in markdown, this lint tries to\nconsider that.",
      "Known problems": "Lots of bad docs won\u2019t be fixed, what the lint checks\nfor is limited, and there are still false positives.",
      "Examples": "```rust\n/// Do something with the foo_bar parameter. See also\n/// that::other::module::foo.\n// ^ `foo_bar` and `that::other::module::foo` should be ticked.\nfn doit(foo_bar) { .. }\n```",
      "Configuration": "This lint has the following configuration variables:\n\n* `doc-valid-idents: Vec<String>`: The list of words this lint should not consider as identifiers needing ticks (defaults to `[\n        \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\",\n        \"DirectX\",\n        \"ECMAScript\",\n        \"GPLv2\", \"GPLv3\",\n        \"GitHub\", \"GitLab\",\n        \"IPv4\", \"IPv6\",\n        \"JavaScript\",\n        \"NaN\", \"NaNs\",\n        \"OAuth\",\n        \"OpenGL\", \"OpenSSH\", \"OpenSSL\", \"OpenStreetMap\",\n        \"TrueType\",\n        \"iOS\", \"macOS\",\n        \"TeX\", \"LaTeX\", \"BibTeX\", \"BibLaTeX\",\n        \"MinGW\",\n        \"CamelCase\",\n    ] `)."
    }
  },
  {
    "id": "double_comparisons",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for double comparisons that could be simplified to a single expression.",
      "Why is this bad": "Readability.",
      "Known problems": "None.",
      "Example": "```rust\nx == y || x < y\n```\nCould be written as:\n```rust\nx <= y\n```"
    }
  },
  {
    "id": "double_parens",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for unnecessary double parentheses.",
      "Why is this bad": "This makes code harder to read and might indicate a\nmistake.",
      "Known problems": "None.",
      "Example": "```rust\n((0))\nfoo((0))\n((1, 2))\n```"
    }
  },
  {
    "id": "drop_bounds",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for generics with `std::ops::Drop` as bounds.",
      "Why is this bad": "`Drop` bounds do not really accomplish anything.\nA type may have compiler-generated drop glue without implementing the\n`Drop` trait itself. The `Drop` trait also only has one method,\n`Drop::drop`, and that function is by fiat not callable in user code.\nSo there is really no use case for using `Drop` in trait bounds.\nThe most likely use case of a drop bound is to distinguish between types\nthat have destructors and types that don't. Combined with specialization,\na naive coder would write an implementation that assumed a type could be\ntrivially dropped, then write a specialization for `T: Drop` that actually\ncalls the destructor. Except that doing so is not correct; String, for\nexample, doesn't actually implement Drop, but because String contains a\nVec, assuming it can be trivially dropped will leak memory.",
      "Known problems": "None.",
      "Example": "```rust\nfn foo<T: Drop>() {}\n```"
    }
  },
  {
    "id": "drop_ref",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for calls to `std::mem::drop` with a reference\ninstead of an owned value.",
      "Why is this bad": "Calling `drop` on a reference will only drop the\nreference itself, which is a no-op. It will not call the `drop` method (from\nthe `Drop` trait implementation) on the underlying referenced value, which\nis likely what was intended.",
      "Known problems": "None.",
      "Example": "```ignore\nlet mut lock_guard = mutex.lock();\nstd::mem::drop(&lock_guard) // Should have been drop(lock_guard), mutex\n// still locked\noperation_that_requires_mutex_to_be_unlocked();\n```"
    }
  },
  {
    "id": "forget_ref",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for calls to `std::mem::forget` with a reference\ninstead of an owned value.",
      "Why is this bad": "Calling `forget` on a reference will only forget the\nreference itself, which is a no-op. It will not forget the underlying\nreferenced\nvalue, which is likely what was intended.",
      "Known problems": "None.",
      "Example": "```rust\nlet x = Box::new(1);\nstd::mem::forget(&x) // Should have been forget(x), x will still be dropped\n```"
    }
  },
  {
    "id": "drop_copy",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for calls to `std::mem::drop` with a value\nthat derives the Copy trait",
      "Why is this bad": "Calling `std::mem::drop` [does nothing for types that\nimplement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html), since the\nvalue will be copied and moved into the function on invocation.",
      "Known problems": "None.",
      "Example": "```rust\nlet x: i32 = 42; // i32 implements Copy\nstd::mem::drop(x) // A copy of x is passed to the function, leaving the\n                  // original unaffected\n```"
    }
  },
  {
    "id": "forget_copy",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for calls to `std::mem::forget` with a value that\nderives the Copy trait",
      "Why is this bad": "Calling `std::mem::forget` [does nothing for types that\nimplement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html) since the\nvalue will be copied and moved into the function on invocation.\nAn alternative, but also valid, explanation is that Copy types do not\nimplement\nthe Drop trait, which means they have no destructors. Without a destructor,\nthere\nis nothing for `std::mem::forget` to ignore.",
      "Known problems": "None.",
      "Example": "```rust\nlet x: i32 = 42; // i32 implements Copy\nstd::mem::forget(x) // A copy of x is passed to the function, leaving the\n                    // original unaffected\n```"
    }
  },
  {
    "id": "duration_subsec",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for calculation of subsecond microseconds or milliseconds\nfrom other `Duration` methods.",
      "Why is this bad": "It's more concise to call `Duration::subsec_micros()` or\n`Duration::subsec_millis()` than to calculate them.",
      "Known problems": "None.",
      "Example": "```rust\nlet dur = Duration::new(5, 0);\nlet _micros = dur.subsec_nanos() / 1_000;\nlet _millis = dur.subsec_nanos() / 1_000_000;\n```"
    }
  },
  {
    "id": "else_if_without_else",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usage of if expressions with an `else if` branch,\nbut without a final `else` branch.",
      "Why is this bad": "Some coding guidelines require this (e.g., MISRA-C:2004 Rule 14.10).",
      "Known problems": "None.",
      "Example": "```rust\nif x.is_positive() {\n    a();\n} else if x.is_negative() {\n    b();\n}\n```\nCould be written:\n```rust\nif x.is_positive() {\n    a();\n} else if x.is_negative() {\n    b();\n} else {\n    // We don't care about zero.\n}\n```"
    }
  },
  {
    "id": "empty_enum",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for `enum`s with no variants.",
      "Why is this bad": "Enum's with no variants should be replaced with `!`,\nthe uninhabited type,\nor a wrapper around it.",
      "Known problems": "None.",
      "Example": "```rust\nenum Test {}\n```"
    }
  },
  {
    "id": "map_entry",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for uses of `contains_key` + `insert` on `HashMap`\nor `BTreeMap`.",
      "Why is this bad": "Using `entry` is more efficient.",
      "Known problems": "Some false negatives, eg.:\n```rust\nlet k = &key;\nif !m.contains_key(k) {\n    m.insert(k.clone(), v);\n}\n```",
      "Example": "```rust\nif !m.contains_key(&k) {\n    m.insert(k, v)\n}\n```\ncan be rewritten as:\n```rust\nm.entry(k).or_insert(v);\n```"
    }
  },
  {
    "id": "enum_clike_unportable_variant",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for C-like enumerations that are\n`repr(isize/usize)` and have values that don't fit into an `i32`.",
      "Why is this bad": "This will truncate the variant value on 32 bit\narchitectures, but works fine on 64 bit.",
      "Known problems": "None.",
      "Example": "```rust\n#[repr(usize)]\nenum NonPortable {\n    X = 0x1_0000_0000,\n    Y = 0,\n}\n```"
    }
  },
  {
    "id": "enum_glob_use",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for `use Enum::*`.",
      "Why is this bad": "It is usually better style to use the prefixed name of\nan enumeration variant, rather than importing variants.",
      "Known problems": "Old-style enumerations that prefix the variants are\nstill around.",
      "Example": "```rust\nuse std::cmp::Ordering::*;\n```"
    }
  },
  {
    "id": "enum_variant_names",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Detects enumeration variants that are prefixed or suffixed\nby the same characters.",
      "Why is this bad": "Enumeration variant names should specify their variant,\nnot repeat the enumeration name.",
      "Known problems": "None.",
      "Example": "```rust\nenum Cake {\n    BlackForestCake,\n    HummingbirdCake,\n    BattenbergCake,\n}\n```",
      "Configuration": "This lint has the following configuration variables:\n\n* `enum-variant-name-threshold: u64`: The minimum number of enum variants for the lints about variant names to trigger (defaults to `3 `)."
    }
  },
  {
    "id": "pub_enum_variant_names",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Detects enumeration variants that are prefixed or suffixed\nby the same characters.",
      "Why is this bad": "Enumeration variant names should specify their variant,\nnot repeat the enumeration name.",
      "Known problems": "None.",
      "Example": "```rust\nenum Cake {\n    BlackForestCake,\n    HummingbirdCake,\n    BattenbergCake,\n}\n```"
    }
  },
  {
    "id": "module_name_repetitions",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Detects type names that are prefixed or suffixed by the\ncontaining module's name.",
      "Why is this bad": "It requires the user to type the module name twice.",
      "Known problems": "None.",
      "Example": "```rust\nmod cake {\n    struct BlackForestCake;\n}\n```"
    }
  },
  {
    "id": "module_inception",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for modules that have the same name as their\nparent module",
      "Why is this bad": "A typical beginner mistake is to have `mod foo;` and\nagain `mod foo { ..\n}` in `foo.rs`.\nThe expectation is that items inside the inner `mod foo { .. }` are then\navailable\nthrough `foo::x`, but they are only available through\n`foo::foo::x`.\nIf this is done on purpose, it would be better to choose a more\nrepresentative module name.",
      "Known problems": "None.",
      "Example": "```ignore\n// lib.rs\nmod foo;\n// foo.rs\nmod foo {\n    ...\n}\n```"
    }
  },
  {
    "id": "eq_op",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for equal operands to comparison, logical and\nbitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n`||`, `&`, `|`, `^`, `-` and `/`).",
      "Why is this bad": "This is usually just a typo or a copy and paste error.",
      "Known problems": "False negatives: We had some false positives regarding\ncalls (notably [racer](https://github.com/phildawes/racer) had one instance\nof `x.pop() && x.pop()`), so we removed matching any function or method\ncalls. We may introduce a whitelist of known pure functions in the future.",
      "Example": "```rust\n# let x = 1;\nif x + 1 == x + 1 {}\n```"
    }
  },
  {
    "id": "op_ref",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for arguments to `==` which have their address\ntaken to satisfy a bound\nand suggests to dereference the other argument instead",
      "Why is this bad": "It is more idiomatic to dereference the other argument.",
      "Known problems": "None",
      "Example": "```ignore\n&x == y\n```"
    }
  },
  {
    "id": "erasing_op",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for erasing operations, e.g., `x * 0`.",
      "Why is this bad": "The whole expression can be replaced by zero.\nThis is most likely not the intended outcome and should probably be\ncorrected",
      "Known problems": "None.",
      "Example": "```rust\nlet x = 1;\n0 / x;\n0 * x;\nx & 0;\n```"
    }
  },
  {
    "id": "boxed_local",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of `Box<T>` where an unboxed `T` would\nwork fine.",
      "Why is this bad": "This is an unnecessary allocation, and bad for\nperformance. It is only necessary to allocate if you wish to move the box\ninto something.",
      "Known problems": "None.",
      "Example": "```rust\nfn main() {\n    let x = Box::new(1);\n    foo(*x);\n    println!(\"{}\", *x);\n}\n```",
      "Configuration": "This lint has the following configuration variables:\n\n* `too-large-for-stack: u64`: The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap (defaults to `200 `)."
    }
  },
  {
    "id": "redundant_closure",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for closures which just call another function where\nthe function can be called directly. `unsafe` functions or calls where types\nget adjusted are ignored.",
      "Why is this bad": "Needlessly creating a closure adds code for no benefit\nand gives the optimizer more work.",
      "Known problems": "If creating the closure inside the closure has a side-\neffect then moving the closure creation out will change when that side-\neffect runs.\nSee rust-lang/rust-clippy#1439 for more details.",
      "Example": "```rust,ignore\nxs.map(|x| foo(x))\n```\nwhere `foo(_)` is a plain function that takes the exact argument type of\n`x`."
    }
  },
  {
    "id": "redundant_closure_for_method_calls",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for closures which only invoke a method on the closure\nargument and can be replaced by referencing the method directly.",
      "Why is this bad": "It's unnecessary to create the closure.",
      "Known problems": "rust-lang/rust-clippy#3071, rust-lang/rust-clippy#4002,\nrust-lang/rust-clippy#3942",
      "Example": "```rust,ignore\nSome('a').map(|s| s.to_uppercase());\n```\nmay be rewritten as\n```rust,ignore\nSome('a').map(char::to_uppercase);\n```"
    }
  },
  {
    "id": "eval_order_dependence",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for a read and a write to the same variable where\nwhether the read occurs before or after the write depends on the evaluation\norder of sub-expressions.",
      "Why is this bad": "It is often confusing to read. In addition, the\nsub-expression evaluation order for Rust is not well documented.",
      "Known problems": "Code which intentionally depends on the evaluation\norder, or which is correct for any evaluation order.",
      "Example": "```rust\nlet mut x = 0;\nlet a = {\n    x = 1;\n    1\n} + x;\n// Unclear whether a is 1 or 2.\n```"
    }
  },
  {
    "id": "diverging_sub_expression",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for diverging calls that are not match arms or\nstatements.",
      "Why is this bad": "It is often confusing to read. In addition, the\nsub-expression evaluation order for Rust is not well documented.",
      "Known problems": "Someone might want to use `some_bool || panic!()` as a\nshorthand.",
      "Example": "```rust\nlet a = b() || panic!() || c();\n// `c()` is dead, `panic!()` is only called if `b()` returns `false`\nlet x = (a, b, c, panic!());\n// can simply be replaced by `panic!()`\n```"
    }
  },
  {
    "id": "excessive_precision",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for float literals with a precision greater\nthan that supported by the underlying type",
      "Why is this bad": "Rust will truncate the literal silently.",
      "Known problems": "None.",
      "Example": "```rust\n// Bad\nlet v: f32 = 0.123_456_789_9;\nprintln!(\"{}\", v); //  0.123_456_789\n// Good\nlet v: f64 = 0.123_456_789_9;\nprintln!(\"{}\", v); //  0.123_456_789_9\n```"
    }
  },
  {
    "id": "explicit_write",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of `write!()` / `writeln()!` which can be\nreplaced with `(e)print!()` / `(e)println!()`",
      "Why is this bad": "Using `(e)println! is clearer and more concise",
      "Known problems": "None.",
      "Example": "```rust\n// this would be clearer as `eprintln!(\"foo: {:?}\", bar);`\nwriteln!(&mut io::stderr(), \"foo: {:?}\", bar).unwrap();\n```"
    }
  },
  {
    "id": "fallible_impl_from",
    "group": "nursery",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for impls of `From<..>` that contain `panic!()` or `unwrap()`",
      "Why is this bad": "`TryFrom` should be used if there's a possibility of failure.",
      "Known problems": "None.",
      "Example": "```rust\nstruct Foo(i32);\nimpl From<String> for Foo {\n    fn from(s: String) -> Self {\n        Foo(s.parse().unwrap())\n    }\n}\n```"
    }
  },
  {
    "id": "useless_format",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for the use of `format!(\"string literal with no\nargument\")` and `format!(\"{}\", foo)` where `foo` is a string.",
      "Why is this bad": "There is no point of doing that. `format!(\"foo\")` can\nbe replaced by `\"foo\".to_owned()` if you really need a `String`. The even\nworse `&format!(\"foo\")` is often encountered in the wild. `format!(\"{}\",\nfoo)` can be replaced by `foo.clone()` if `foo: String` or `foo.to_owned()`\nif `foo: &str`.",
      "Known problems": "None.",
      "Examples": "```rust\nformat!(\"foo\")\nformat!(\"{}\", foo)\n```"
    }
  },
  {
    "id": "suspicious_assignment_formatting",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for use of the non-existent `=*`, `=!` and `=-`\noperators.",
      "Why is this bad": "This is either a typo of `*=`, `!=` or `-=` or\nconfusing.",
      "Known problems": "None.",
      "Example": "```rust,ignore\na =- 42; // confusing, should it be `a -= 42` or `a = -42`?\n```"
    }
  },
  {
    "id": "suspicious_else_formatting",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for formatting of `else`. It lints if the `else`\nis followed immediately by a newline or the `else` seems to be missing.",
      "Why is this bad": "This is probably some refactoring remnant, even if the\ncode is correct, it might look confusing.",
      "Known problems": "None.",
      "Example": "```rust,ignore\nif foo {\n} { // looks like an `else` is missing here\n}\nif foo {\n} if bar { // looks like an `else` is missing here\n}\nif foo {\n} else\n{ // this is the `else` block of the previous `if`, but should it be?\n}\nif foo {\n} else\nif bar { // this is the `else` block of the previous `if`, but should it be?\n}\n```"
    }
  },
  {
    "id": "possible_missing_comma",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for possible missing comma in an array. It lints if\nan array element is a binary operator expression and it lies on two lines.",
      "Why is this bad": "This could lead to unexpected results.",
      "Known problems": "None.",
      "Example": "```rust,ignore\nlet a = &[\n    -1, -2, -3 // <= no comma here\n    -4, -5, -6\n];\n```"
    }
  },
  {
    "id": "too_many_arguments",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for functions with too many parameters.",
      "Why is this bad": "Functions with lots of parameters are considered bad\nstyle and reduce readability (\u201cwhat does the 5th parameter mean?\u201d). Consider\ngrouping some parameters into a new type.",
      "Known problems": "None.",
      "Example": "```rust\nfn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) {\n    ..\n}\n```",
      "Configuration": "This lint has the following configuration variables:\n\n* `too-many-arguments-threshold: u64`: The maximum number of argument a function or method can have (defaults to `7 `)."
    }
  },
  {
    "id": "too_many_lines",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for functions with a large amount of lines.",
      "Why is this bad": "Functions with a lot of lines are harder to understand\ndue to having to look at a larger amount of code to understand what the\nfunction is doing. Consider splitting the body of the function into\nmultiple functions.",
      "Known problems": "None.",
      "Example": "``` rust\nfn im_too_long() {\nprintln!(\"\");\n// ... 100 more LoC\nprintln!(\"\");\n}\n```",
      "Configuration": "This lint has the following configuration variables:\n\n* `too-many-lines-threshold: u64`: The maximum number of lines a function or method can have (defaults to `100 `)."
    }
  },
  {
    "id": "not_unsafe_ptr_arg_deref",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for public functions that dereference raw pointer\narguments but are not marked unsafe.",
      "Why is this bad": "The function should probably be marked `unsafe`, since\nfor an arbitrary raw pointer, there is no way of telling for sure if it is\nvalid.",
      "Known problems": "* It does not check functions recursively so if the pointer is passed to a\nprivate non-`unsafe` function which does the dereferencing, the lint won't\ntrigger.\n* It only checks for arguments whose type are raw pointers, not raw pointers\ngot from an argument in some other way (`fn foo(bar: &[*const u8])` or\n`some_argument.get_raw_ptr()`).",
      "Example": "```rust\npub fn foo(x: *const u8) {\n    println!(\"{}\", unsafe { *x });\n}\n```"
    }
  },
  {
    "id": "get_last_with_len",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for using `x.get(x.len() - 1)` instead of\n`x.last()`.",
      "Why is this bad": "Using `x.last()` is easier to read and has the same\nresult.\nNote that using `x[x.len() - 1]` is semantically different from\n`x.last()`.  Indexing into the array will panic on out-of-bounds\naccesses, while `x.get()` and `x.last()` will return `None`.\nThere is another lint (get_unwrap) that covers the case of using\n`x.get(index).unwrap()` instead of `x[index]`.",
      "Known problems": "None.",
      "Example": "```rust\n// Bad\nlet x = vec![2, 3, 5];\nlet last_element = x.get(x.len() - 1);\n// Good\nlet x = vec![2, 3, 5];\nlet last_element = x.last();\n```"
    }
  },
  {
    "id": "identity_conversion",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for always-identical `Into`/`From`/`IntoIter` conversions.",
      "Why is this bad": "Redundant code.",
      "Known problems": "None.",
      "Example": "```rust\n// format!() returns a `String`\nlet s: String = format!(\"hello\").into();\n```"
    }
  },
  {
    "id": "identity_op",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for identity operations, e.g., `x + 0`.",
      "Why is this bad": "This code can be removed without changing the\nmeaning. So it just obscures what's going on. Delete it mercilessly.",
      "Known problems": "None.",
      "Example": "```rust\nx / 1 + 0 * 1 - 0 | 0\n```"
    }
  },
  {
    "id": "if_not_else",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usage of `!` or `!=` in an if condition with an\nelse branch.",
      "Why is this bad": "Negations reduce the readability of statements.",
      "Known problems": "None.",
      "Example": "```rust\nif !v.is_empty() {\n    a()\n} else {\n    b()\n}\n```\nCould be written:\n```rust\nif v.is_empty() {\n    b()\n} else {\n    a()\n}\n```"
    }
  },
  {
    "id": "implicit_return",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for missing return statements at the end of a block.",
      "Why is this bad": "Actually omitting the return keyword is idiomatic Rust code. Programmers\ncoming from other languages might prefer the expressiveness of `return`. It's possible to miss\nthe last returning statement because the only difference is a missing `;`. Especially in bigger\ncode with multiple return paths having a `return` keyword makes it easier to find the\ncorresponding statements.",
      "Known problems": "None.",
      "Example": "```rust\nfn foo(x: usize) -> usize {\n    x\n}\n```\nadd return\n```rust\nfn foo(x: usize) -> usize {\n    return x;\n}\n```"
    }
  },
  {
    "id": "out_of_bounds_indexing",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for out of bounds array indexing with a constant\nindex.",
      "Why is this bad": "This will always panic at runtime.",
      "Known problems": "Hopefully none.",
      "Example": "```no_run\n# #![allow(const_err)]\nlet x = [1, 2, 3, 4];\n// Bad\nx[9];\n&x[2..9];\n// Good\nx[0];\nx[3];\n```"
    }
  },
  {
    "id": "indexing_slicing",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usage of indexing or slicing. Arrays are special cases, this lint\ndoes report on arrays if we can tell that slicing operations are in bounds and does not\nlint on constant `usize` indexing on arrays because that is handled by rustc's `const_err` lint.",
      "Why is this bad": "Indexing and slicing can panic at runtime and there are\nsafe alternatives.",
      "Known problems": "Hopefully none.",
      "Example": "```rust\n// Vector\nlet x = vec![0; 5];\n// Bad\nx[2];\n&x[2..100];\n&x[2..];\n&x[..100];\n// Good\nx.get(2);\nx.get(2..100);\nx.get(2..);\nx.get(..100);\n// Array\nlet y = [0, 1, 2, 3];\n// Bad\n&y[10..100];\n&y[10..];\n&y[..100];\n// Good\n&y[2..];\n&y[..2];\n&y[0..3];\ny.get(10);\ny.get(10..100);\ny.get(10..);\ny.get(..100);\n```"
    }
  },
  {
    "id": "infallible_destructuring_match",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for matches being used to destructure a single-variant enum\nor tuple struct where a `let` will suffice.",
      "Why is this bad": "Just readability \u2013 `let` doesn't nest, whereas a `match` does.",
      "Known problems": "None.",
      "Example": "```rust\nenum Wrapper {\n    Data(i32),\n}\nlet wrapper = Wrapper::Data(42);\nlet data = match wrapper {\n    Wrapper::Data(i) => i,\n};\n```\nThe correct use would be:\n```rust\nenum Wrapper {\n    Data(i32),\n}\nlet wrapper = Wrapper::Data(42);\nlet Wrapper::Data(data) = wrapper;\n```"
    }
  },
  {
    "id": "infinite_iter",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for iteration that is guaranteed to be infinite.",
      "Why is this bad": "While there may be places where this is acceptable\n(e.g., in event streams), in most cases this is simply an error.",
      "Known problems": "None.",
      "Example": "```no_run\nuse std::iter;\niter::repeat(1_u8).collect::<Vec<_>>();\n```"
    }
  },
  {
    "id": "maybe_infinite_iter",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for iteration that may be infinite.",
      "Why is this bad": "While there may be places where this is acceptable\n(e.g., in event streams), in most cases this is simply an error.",
      "Known problems": "The code may have a condition to stop iteration, but\nthis lint is not clever enough to analyze it.",
      "Example": "```rust\n[0..].iter().zip(infinite_iter.take_while(|x| x > 5))\n```"
    }
  },
  {
    "id": "multiple_inherent_impl",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for multiple inherent implementations of a struct",
      "Why is this bad": "Splitting the implementation of a type makes the code harder to navigate.",
      "Known problems": "None.",
      "Example": "```rust\nstruct X;\nimpl X {\n    fn one() {}\n}\nimpl X {\n    fn other() {}\n}\n```\nCould be written:\n```rust\nstruct X;\nimpl X {\n    fn one() {}\n    fn other() {}\n}\n```"
    }
  },
  {
    "id": "inline_fn_without_body",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for `#[inline]` on trait methods without bodies",
      "Why is this bad": "Only implementations of trait methods may be inlined.\nThe inline attribute is ignored for trait methods without bodies.",
      "Known problems": "None.",
      "Example": "```rust\ntrait Animal {\n    #[inline]\n    fn name(&self) -> &'static str;\n}\n```"
    }
  },
  {
    "id": "int_plus_one",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of `x >= y + 1` or `x - 1 >= y` (and `<=`) in a block",
      "Why is this bad": "Readability -- better to use `> y` instead of `>= y + 1`.",
      "Known problems": "None.",
      "Example": "```rust\nx >= y + 1\n```\nCould be written:\n```rust\nx > y\n```"
    }
  },
  {
    "id": "integer_division",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for division of integers",
      "Why is this bad": "When outside of some very specific algorithms,\ninteger division is very often a mistake because it discards the\nremainder.",
      "Known problems": "None.",
      "Example": "```rust\nfn main() {\n    let x = 3 / 2;\n    println!(\"{}\", x);\n}\n```"
    }
  },
  {
    "id": "invalid_ref",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for creation of references to zeroed or uninitialized memory.",
      "Why is this bad": "Creation of null references is undefined behavior.",
      "Known problems": "None.",
      "Example": "```no_run\nlet bad_ref: &usize = unsafe { std::mem::zeroed() };\n```"
    }
  },
  {
    "id": "items_after_statements",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for items declared after some statement in a block.",
      "Why is this bad": "Items live for the entire scope they are declared\nin. But statements are processed in order. This might cause confusion as\nit's hard to figure out which item is meant in a statement.",
      "Known problems": "None.",
      "Example": "```rust\nfn foo() {\n    println!(\"cake\");\n}\nfn main() {\n    foo(); // prints \"foo\"\n    fn foo() {\n        println!(\"foo\");\n    }\n    foo(); // prints \"foo\"\n}\n```"
    }
  },
  {
    "id": "large_enum_variant",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for large size differences between variants on\n`enum`s.",
      "Why is this bad": "Enum size is bounded by the largest variant. Having a\nlarge variant\ncan penalize the memory layout of that enum.",
      "Known problems": "None.",
      "Example": "```rust\nenum Test {\n    A(i32),\n    B([i32; 8000]),\n}\n```",
      "Configuration": "This lint has the following configuration variables:\n\n* `enum-variant-size-threshold: u64`: The maximum size of a enum's variant to avoid box suggestion (defaults to `200 `)."
    }
  },
  {
    "id": "len_zero",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for getting the length of something via `.len()`\njust to compare to zero, and suggests using `.is_empty()` where applicable.",
      "Why is this bad": "Some structures can answer `.is_empty()` much faster\nthan calculating their length. Notably, for slices, getting the length\nrequires a subtraction whereas `.is_empty()` is just a comparison. So it is\ngood to get into the habit of using `.is_empty()`, and having it is cheap.\nBesides, it makes the intent clearer than a manual comparison.",
      "Known problems": "None.",
      "Example": "```ignore\nif x.len() == 0 {\n    ..\n}\nif y.len() != 0 {\n    ..\n}\n```\ninstead use\n```ignore\nif x.is_empty() {\n    ..\n}\nif !y.is_empty() {\n    ..\n}\n```"
    }
  },
  {
    "id": "len_without_is_empty",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for items that implement `.len()` but not\n`.is_empty()`.",
      "Why is this bad": "It is good custom to have both methods, because for\nsome data structures, asking about the length will be a costly operation,\nwhereas `.is_empty()` can usually answer in constant time. Also it used to\nlead to false positives on the [`len_zero`](#len_zero) lint \u2013 currently that\nlint will ignore such entities.",
      "Known problems": "None.",
      "Example": "```ignore\nimpl X {\n    pub fn len(&self) -> usize {\n        ..\n    }\n}\n```"
    }
  },
  {
    "id": "useless_let_if_seq",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for variable declarations immediately followed by a\nconditional affectation.",
      "Why is this bad": "This is not idiomatic Rust.",
      "Known problems": "None.",
      "Example": "```rust,ignore\nlet foo;\nif bar() {\n    foo = 42;\n} else {\n    foo = 0;\n}\nlet mut baz = None;\nif bar() {\n    baz = Some(42);\n}\n```\nshould be written\n```rust,ignore\nlet foo = if bar() {\n    42\n} else {\n    0\n};\nlet baz = if bar() {\n    Some(42)\n} else {\n    None\n};\n```"
    }
  },
  {
    "id": "needless_lifetimes",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for lifetime annotations which can be removed by\nrelying on lifetime elision.",
      "Why is this bad": "The additional lifetimes make the code look more\ncomplicated, while there is nothing out of the ordinary going on. Removing\nthem leads to more readable code.",
      "Known problems": "Potential false negatives: we bail out if the function\nhas a `where` clause where lifetimes are mentioned.",
      "Example": "```rust\nfn in_and_out<'a>(x: &'a u8, y: u8) -> &'a u8 {\n    x\n}\n```"
    }
  },
  {
    "id": "extra_unused_lifetimes",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for lifetimes in generics that are never used\nanywhere else.",
      "Why is this bad": "The additional lifetimes make the code look more\ncomplicated, while there is nothing out of the ordinary going on. Removing\nthem leads to more readable code.",
      "Known problems": "None.",
      "Example": "```rust\nfn unused_lifetime<'a>(x: u8) {\n    ..\n}\n```"
    }
  },
  {
    "id": "unreadable_literal",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Warns if a long integral or floating-point constant does\nnot contain underscores.",
      "Why is this bad": "Reading long numbers is difficult without separators.",
      "Known problems": "None.",
      "Example": "```rust\nlet x: u64 = 61864918973511;\n```"
    }
  },
  {
    "id": "mistyped_literal_suffixes",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Warns for mistyped suffix in literals",
      "Why is this bad": "This is most probably a typo",
      "Known problems": "- Recommends a signed suffix, even though the number might be too big and an unsigned\n\t\tsuffix is required\n\t\t- Does not match on `_128` since that is a valid grouping for decimal and octal numbers",
      "Example": "```rust\n2_32;\n```"
    }
  },
  {
    "id": "inconsistent_digit_grouping",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Warns if an integral or floating-point constant is\ngrouped inconsistently with underscores.",
      "Why is this bad": "Readers may incorrectly interpret inconsistently\ngrouped digits.",
      "Known problems": "None.",
      "Example": "```rust\nlet x: u64 = 618_64_9189_73_511;\n```"
    }
  },
  {
    "id": "large_digit_groups",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Warns if the digits of an integral or floating-point\nconstant are grouped into groups that\nare too large.",
      "Why is this bad": "Negatively impacts readability.",
      "Known problems": "None.",
      "Example": "```rust\nlet x: u64 = 6186491_8973511;\n```"
    }
  },
  {
    "id": "decimal_literal_representation",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Warns if there is a better representation for a numeric literal.",
      "Why is this bad": "Especially for big powers of 2 a hexadecimal representation is more\nreadable than a decimal representation.",
      "Known problems": "None.",
      "Example": "`255` => `0xFF`\n`65_535` => `0xFFFF`\n`4_042_322_160` => `0xF0F0_F0F0`",
      "Configuration": "This lint has the following configuration variables:\n\n* `literal-representation-threshold: u64`: The lower bound for linting decimal literals (defaults to `16384 `)."
    }
  },
  {
    "id": "manual_memcpy",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for for-loops that manually copy items between\nslices that could be optimized by having a memcpy.",
      "Why is this bad": "It is not as fast as a memcpy.",
      "Known problems": "None.",
      "Example": "```ignore\nfor i in 0..src.len() {\n    dst[i + 64] = src[i];\n}\n```"
    }
  },
  {
    "id": "needless_range_loop",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for looping over the range of `0..len` of some\ncollection just to get the values by index.",
      "Why is this bad": "Just iterating the collection itself makes the intent\nmore clear and is probably faster.",
      "Known problems": "None.",
      "Example": "```rust\nlet vec = vec!['a', 'b', 'c'];\nfor i in 0..vec.len() {\n    println!(\"{}\", vec[i]);\n}\n```\nCould be written as:\n```rust\nlet vec = vec!['a', 'b', 'c'];\nfor i in vec {\n    println!(\"{}\", i);\n}\n```"
    }
  },
  {
    "id": "explicit_iter_loop",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for loops on `x.iter()` where `&x` will do, and\nsuggests the latter.",
      "Why is this bad": "Readability.",
      "Known problems": "False negatives. We currently only warn on some known\ntypes.",
      "Example": "```ignore\n// with `y` a `Vec` or slice:\nfor x in y.iter() {\n    ..\n}\n```\ncan be rewritten to\n```rust\nfor x in &y {\n    ..\n}\n```"
    }
  },
  {
    "id": "explicit_into_iter_loop",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for loops on `y.into_iter()` where `y` will do, and\nsuggests the latter.",
      "Why is this bad": "Readability.",
      "Known problems": "None",
      "Example": "```ignore\n// with `y` a `Vec` or slice:\nfor x in y.into_iter() {\n    ..\n}\n```\ncan be rewritten to\n```ignore\nfor x in y {\n    ..\n}\n```"
    }
  },
  {
    "id": "iter_next_loop",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for loops on `x.next()`.",
      "Why is this bad": "`next()` returns either `Some(value)` if there was a\nvalue, or `None` otherwise. The insidious thing is that `Option<_>`\nimplements `IntoIterator`, so that possibly one value will be iterated,\nleading to some hard to find bugs. No one will want to write such code\n[except to win an Underhanded Rust\nContest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).",
      "Known problems": "None.",
      "Example": "```ignore\nfor x in y.next() {\n    ..\n}\n```"
    }
  },
  {
    "id": "for_loop_over_option",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for `for` loops over `Option` values.",
      "Why is this bad": "Readability. This is more clearly expressed as an `if\nlet`.",
      "Known problems": "None.",
      "Example": "```ignore\nfor x in option {\n    ..\n}\n```\nThis should be\n```ignore\nif let Some(x) = option {\n    ..\n}\n```"
    }
  },
  {
    "id": "for_loop_over_result",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for `for` loops over `Result` values.",
      "Why is this bad": "Readability. This is more clearly expressed as an `if\nlet`.",
      "Known problems": "None.",
      "Example": "```ignore\nfor x in result {\n    ..\n}\n```\nThis should be\n```ignore\nif let Ok(x) = result {\n    ..\n}\n```"
    }
  },
  {
    "id": "while_let_loop",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Detects `loop + match` combinations that are easier\nwritten as a `while let` loop.",
      "Why is this bad": "The `while let` loop is usually shorter and more\nreadable.",
      "Known problems": "Sometimes the wrong binding is displayed (#383).",
      "Example": "```rust\nloop {\n    let x = match y {\n        Some(x) => x,\n        None => break,\n    }\n    // .. do something with x\n}\n// is easier written as\nwhile let Some(x) = y {\n    // .. do something with x\n}\n```"
    }
  },
  {
    "id": "unused_collect",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for using `collect()` on an iterator without using\nthe result.",
      "Why is this bad": "It is more idiomatic to use a `for` loop over the\niterator instead.",
      "Known problems": "None.",
      "Example": "```ignore\nvec.iter().map(|x| /* some operation returning () */).collect::<Vec<_>>();\n```"
    }
  },
  {
    "id": "needless_collect",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for functions collecting an iterator when collect\nis not needed.",
      "Why is this bad": "`collect` causes the allocation of a new data structure,\nwhen this allocation may not be needed.",
      "Known problems": "None",
      "Example": "```ignore\nlet len = iterator.collect::<Vec<_>>().len();\n// should be\nlet len = iterator.count();\n```"
    }
  },
  {
    "id": "reverse_range_loop",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for loops over ranges `x..y` where both `x` and `y`\nare constant and `x` is greater or equal to `y`, unless the range is\nreversed or has a negative `.step_by(_)`.",
      "Why is it bad": "Such loops will either be skipped or loop until\nwrap-around (in debug code, this may `panic!()`). Both options are probably\nnot intended.",
      "Known problems": "The lint cannot catch loops over dynamically defined\nranges. Doing this would require simulating all possible inputs and code\npaths through the program, which would be complex and error-prone.",
      "Example": "```ignore\nfor x in 5..10 - 5 {\n    ..\n} // oops, stray `-`\n```"
    }
  },
  {
    "id": "explicit_counter_loop",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks `for` loops over slices with an explicit counter\nand suggests the use of `.enumerate()`.",
      "Why is it bad": "Not only is the version using `.enumerate()` more\nreadable, the compiler is able to remove bounds checks which can lead to\nfaster code in some instances.",
      "Known problems": "None.",
      "Example": "```ignore\nfor i in 0..v.len() { foo(v[i]);\nfor i in 0..v.len() { bar(i, v[i]); }\n```"
    }
  },
  {
    "id": "empty_loop",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for empty `loop` expressions.",
      "Why is this bad": "Those busy loops burn CPU cycles without doing\nanything. Think of the environment and either block on something or at least\nmake the thread sleep for some microseconds.",
      "Known problems": "None.",
      "Example": "```no_run\nloop {}\n```"
    }
  },
  {
    "id": "while_let_on_iterator",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for `while let` expressions on iterators.",
      "Why is this bad": "Readability. A simple `for` loop is shorter and conveys\nthe intent better.",
      "Known problems": "None.",
      "Example": "```ignore\nwhile let Some(val) = iter() {\n    ..\n}\n```"
    }
  },
  {
    "id": "for_kv_map",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for iterating a map (`HashMap` or `BTreeMap`) and\nignoring either the keys or values.",
      "Why is this bad": "Readability. There are `keys` and `values` methods that\ncan be used to express that don't need the values or keys.",
      "Known problems": "None.",
      "Example": "```ignore\nfor (k, _) in &map {\n    ..\n}\n```\ncould be replaced by\n```ignore\nfor k in map.keys() {\n    ..\n}\n```"
    }
  },
  {
    "id": "never_loop",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for loops that will always `break`, `return` or\n`continue` an outer loop.",
      "Why is this bad": "This loop never loops, all it does is obfuscating the\ncode.",
      "Known problems": "None",
      "Example": "```rust\nloop {\n    ..;\n    break;\n}\n```"
    }
  },
  {
    "id": "mut_range_bound",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for loops which have a range bound that is a mutable variable",
      "Why is this bad": "One might think that modifying the mutable variable changes the loop bounds",
      "Known problems": "None",
      "Example": "```rust\nlet mut foo = 42;\nfor i in 0..foo {\n    foo -= 1;\n    println!(\"{}\", i); // prints numbers from 0 to 42, not 0 to 21\n}\n```"
    }
  },
  {
    "id": "while_immutable_condition",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks whether variables used within while loop condition\ncan be (and are) mutated in the body.",
      "Why is this bad": "If the condition is unchanged, entering the body of the loop\nwill lead to an infinite loop.",
      "Known problems": "If the `while`-loop is in a closure, the check for mutation of the\ncondition variables in the body can cause false negatives. For example when only `Upvar` `a` is\nin the condition and only `Upvar` `b` gets mutated in the body, the lint will not trigger.",
      "Example": "```rust\nlet i = 0;\nwhile i > 10 {\n    println!(\"let me loop forever!\");\n}\n```"
    }
  },
  {
    "id": "map_clone",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of `iterator.map(|x| x.clone())` and suggests\n`iterator.cloned()` instead",
      "Why is this bad": "Readability, this can be written more concisely",
      "Known problems": "None",
      "Example": "```rust\nlet x = vec![42, 43];\nlet y = x.iter();\nlet z = y.map(|i| *i);\n```\nThe correct use would be:\n```rust\nlet x = vec![42, 43];\nlet y = x.iter();\nlet z = y.cloned();\n```"
    }
  },
  {
    "id": "option_map_unit_fn",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of `option.map(f)` where f is a function\nor closure that returns the unit type.",
      "Why is this bad": "Readability, this can be written more clearly with\nan if let statement",
      "Known problems": "None.",
      "Example": "```rust\nlet x: Option<&str> = do_stuff();\nx.map(log_err_msg);\nx.map(|msg| log_err_msg(format_msg(msg)))\n```\nThe correct use would be:\n```rust\nlet x: Option<&str> = do_stuff();\nif let Some(msg) = x {\n    log_err_msg(msg)\n}\nif let Some(msg) = x {\n    log_err_msg(format_msg(msg))\n}\n```"
    }
  },
  {
    "id": "result_map_unit_fn",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of `result.map(f)` where f is a function\nor closure that returns the unit type.",
      "Why is this bad": "Readability, this can be written more clearly with\nan if let statement",
      "Known problems": "None.",
      "Example": "```rust\nlet x: Result<&str, &str> = do_stuff();\nx.map(log_err_msg);\nx.map(|msg| log_err_msg(format_msg(msg)))\n```\nThe correct use would be:\n```rust\nlet x: Result<&str, &str> = do_stuff();\nif let Ok(msg) = x {\n    log_err_msg(msg)\n}\nif let Ok(msg) = x {\n    log_err_msg(format_msg(msg))\n}\n```"
    }
  },
  {
    "id": "single_match",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for matches with a single arm where an `if let`\nwill usually suffice.",
      "Why is this bad": "Just readability \u2013 `if let` nests less than a `match`.",
      "Known problems": "None.",
      "Example": "```rust\n# fn bar(stool: &str) {}\n# let x = Some(\"abc\");\nmatch x {\n    Some(ref foo) => bar(foo),\n    _ => (),\n}\n```"
    }
  },
  {
    "id": "single_match_else",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for matches with a two arms where an `if let else` will\nusually suffice.",
      "Why is this bad": "Just readability \u2013 `if let` nests less than a `match`.",
      "Known problems": "Personal style preferences may differ.",
      "Example": "Using `match`:\n```rust\nmatch x {\n    Some(ref foo) => bar(foo),\n    _ => bar(other_ref),\n}\n```\nUsing `if let` with `else`:\n```rust\nif let Some(ref foo) = x {\n    bar(foo);\n} else {\n    bar(other_ref);\n}\n```"
    }
  },
  {
    "id": "match_ref_pats",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for matches where all arms match a reference,\nsuggesting to remove the reference and deref the matched expression\ninstead. It also checks for `if let &foo = bar` blocks.",
      "Why is this bad": "It just makes the code less readable. That reference\ndestructuring adds nothing to the code.",
      "Known problems": "None.",
      "Example": "```rust,ignore\nmatch x {\n    &A(ref y) => foo(y),\n    &B => bar(),\n    _ => frob(&x),\n}\n```"
    }
  },
  {
    "id": "match_bool",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for matches where match expression is a `bool`. It\nsuggests to replace the expression with an `if...else` block.",
      "Why is this bad": "It makes the code less readable.",
      "Known problems": "None.",
      "Example": "```rust\n# fn foo() {}\n# fn bar() {}\nlet condition: bool = true;\nmatch condition {\n    true => foo(),\n    false => bar(),\n}\n```\nUse if/else instead:\n```rust\n# fn foo() {}\n# fn bar() {}\nlet condition: bool = true;\nif condition {\n    foo();\n} else {\n    bar();\n}\n```"
    }
  },
  {
    "id": "match_overlapping_arm",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for overlapping match arms.",
      "Why is this bad": "It is likely to be an error and if not, makes the code\nless obvious.",
      "Known problems": "None.",
      "Example": "```rust\nlet x = 5;\nmatch x {\n    1...10 => println!(\"1 ... 10\"),\n    5...15 => println!(\"5 ... 15\"),\n    _ => (),\n}\n```"
    }
  },
  {
    "id": "match_wild_err_arm",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for arm which matches all errors with `Err(_)`\nand take drastic actions like `panic!`.",
      "Why is this bad": "It is generally a bad practice, just like\ncatching all exceptions in java with `catch(Exception)`",
      "Known problems": "None.",
      "Example": "```rust\nlet x: Result<i32, &str> = Ok(3);\nmatch x {\n    Ok(_) => println!(\"ok\"),\n    Err(_) => panic!(\"err\"),\n}\n```"
    }
  },
  {
    "id": "match_as_ref",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for match which is used to add a reference to an\n`Option` value.",
      "Why is this bad": "Using `as_ref()` or `as_mut()` instead is shorter.",
      "Known problems": "None.",
      "Example": "```rust\nlet x: Option<()> = None;\nlet r: Option<&()> = match x {\n    None => None,\n    Some(ref v) => Some(v),\n};\n```"
    }
  },
  {
    "id": "wildcard_enum_match_arm",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for wildcard enum matches using `_`.",
      "Why is this bad": "New enum variants added by library updates can be missed.",
      "Known problems": "Suggested replacements may be incorrect if guards exhaustively cover some\nvariants, and also may not use correct path to enum if it's not present in the current scope.",
      "Example": "```rust\nmatch x {\n    A => {},\n    _ => {},\n}\n```"
    }
  },
  {
    "id": "mem_discriminant_non_enum",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for calls of `mem::discriminant()` on a non-enum type.",
      "Why is this bad": "The value of `mem::discriminant()` on non-enum types\nis unspecified.",
      "Known problems": "None.",
      "Example": "```rust\nuse std::mem;\nmem::discriminant(&\"hello\");\nmem::discriminant(&&Some(2));\n```"
    }
  },
  {
    "id": "mem_forget",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usage of `std::mem::forget(t)` where `t` is\n`Drop`.",
      "Why is this bad": "`std::mem::forget(t)` prevents `t` from running its\ndestructor, possibly causing leaks.",
      "Known problems": "None.",
      "Example": "```rust\nmem::forget(Rc::new(55))\n```"
    }
  },
  {
    "id": "mem_replace_option_with_none",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for `mem::replace()` on an `Option` with\n`None`.",
      "Why is this bad": "`Option` already has the method `take()` for\ntaking its current value (Some(..) or None) and replacing it with\n`None`.",
      "Known problems": "None.",
      "Example": "```rust\nuse std::mem;\nlet mut an_option = Some(0);\nlet replaced = mem::replace(&mut an_option, None);\n```\nIs better expressed with:\n```rust\nlet mut an_option = Some(0);\nlet taken = an_option.take();\n```"
    }
  },
  {
    "id": "min_max",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for expressions where `std::cmp::min` and `max` are\nused to clamp values, but switched so that the result is constant.",
      "Why is this bad": "This is in all probability not the intended outcome. At\nthe least it hurts readability of the code.",
      "Known problems": "None",
      "Example": "```ignore\nmin(0, max(100, x))\n```\nIt will always be equal to `0`. Probably the author meant to clamp the value\nbetween 0 and 100, but has erroneously swapped `min` and `max`."
    }
  },
  {
    "id": "toplevel_ref_arg",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for function arguments and let bindings denoted as\n`ref`.",
      "Why is this bad": "The `ref` declaration makes the function take an owned\nvalue, but turns the argument into a reference (which means that the value\nis destroyed when exiting the function). This adds not much value: either\ntake a reference type, or take an owned value and create references in the\nbody.\nFor let bindings, `let x = &foo;` is preferred over `let ref x = foo`. The\ntype of `x` is more obvious with the former.",
      "Known problems": "If the argument is dereferenced within the function,\nremoving the `ref` will lead to errors. This can be fixed by removing the\ndereferences, e.g., changing `*x` to `x` within the function.",
      "Example": "```rust\nfn foo(ref x: u8) -> bool {\n    true\n}\n```"
    }
  },
  {
    "id": "cmp_nan",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for comparisons to NaN.",
      "Why is this bad": "NaN does not compare meaningfully to anything \u2013 not\neven itself \u2013 so those comparisons are simply wrong.",
      "Known problems": "None.",
      "Example": "```rust\n# use core::f32::NAN;\n# let x = 1.0;\nif x == NAN { }\n```"
    }
  },
  {
    "id": "float_cmp",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for (in-)equality comparisons on floating-point\nvalues (apart from zero), except in functions called `*eq*` (which probably\nimplement equality for a type involving floats).",
      "Why is this bad": "Floating point calculations are usually imprecise, so\nasking if two values are *exactly* equal is asking for trouble. For a good\nguide on what to do, see [the floating point\nguide](http://www.floating-point-gui.de/errors/comparison).",
      "Known problems": "None.",
      "Example": "```rust\nlet x = 1.2331f64;\nlet y = 1.2332f64;\nif y == 1.23f64 { }\nif y != x {} // where both are floats\n```"
    }
  },
  {
    "id": "cmp_owned",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for conversions to owned values just for the sake\nof a comparison.",
      "Why is this bad": "The comparison can operate on a reference, so creating\nan owned value effectively throws it away directly afterwards, which is\nneedlessly consuming code and heap space.",
      "Known problems": "None.",
      "Example": "```rust\nx.to_owned() == y\n```"
    }
  },
  {
    "id": "modulo_one",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for getting the remainder of a division by one.",
      "Why is this bad": "The result can only ever be zero. No one will write\nsuch code deliberately, unless trying to win an Underhanded Rust\nContest. Even for that contest, it's probably a bad idea. Use something more\nunderhanded.",
      "Known problems": "None.",
      "Example": "```rust\n# let x = 1;\nlet a = x % 1;\n```"
    }
  },
  {
    "id": "redundant_pattern",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for patterns in the form `name @ _`.",
      "Why is this bad": "It's almost always more readable to just use direct\nbindings.",
      "Known problems": "None.",
      "Example": "```rust\n# let v = Some(\"abc\");\nmatch v {\n    Some(x) => (),\n    y @ _ => (), // easier written as `y`,\n}\n```"
    }
  },
  {
    "id": "used_underscore_binding",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for the use of bindings with a single leading\nunderscore.",
      "Why is this bad": "A single leading underscore is usually used to indicate\nthat a binding will not be used. Using such a binding breaks this\nexpectation.",
      "Known problems": "The lint does not work properly with desugaring and\nmacro, it has been allowed in the mean time.",
      "Example": "```rust\nlet _x = 0;\nlet y = _x + 1; // Here we are using `_x`, even though it has a leading\n                // underscore. We should rename `_x` to `x`\n```"
    }
  },
  {
    "id": "short_circuit_statement",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for the use of short circuit boolean conditions as\na\nstatement.",
      "Why is this bad": "Using a short circuit boolean condition as a statement\nmay hide the fact that the second part is executed or not depending on the\noutcome of the first part.",
      "Known problems": "None.",
      "Example": "```rust\nf() && g(); // We should write `if f() { g(); }`.\n```"
    }
  },
  {
    "id": "zero_ptr",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Catch casts from `0` to some pointer type",
      "Why is this bad": "This generally means `null` and is better expressed as\n{`std`, `core`}`::ptr::`{`null`, `null_mut`}.",
      "Known problems": "None.",
      "Example": "```rust\nlet a = 0 as *const u32;\n```"
    }
  },
  {
    "id": "float_cmp_const",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for (in-)equality comparisons on floating-point\nvalue and constant, except in functions called `*eq*` (which probably\nimplement equality for a type involving floats).",
      "Why is this bad": "Floating point calculations are usually imprecise, so\nasking if two values are *exactly* equal is asking for trouble. For a good\nguide on what to do, see [the floating point\nguide](http://www.floating-point-gui.de/errors/comparison).",
      "Known problems": "None.",
      "Example": "```rust\nconst ONE = 1.00f64;\nx == ONE  // where both are floats\n```"
    }
  },
  {
    "id": "unneeded_field_pattern",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for structure field patterns bound to wildcards.",
      "Why is this bad": "Using `..` instead is shorter and leaves the focus on\nthe fields that are actually bound.",
      "Known problems": "None.",
      "Example": "```ignore\nlet { a: _, b: ref b, c: _ } = ..\n```"
    }
  },
  {
    "id": "duplicate_underscore_argument",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for function arguments having the similar names\ndiffering by an underscore.",
      "Why is this bad": "It affects code readability.",
      "Known problems": "None.",
      "Example": "```rust\nfn foo(a: i32, _a: i32) {}\n```"
    }
  },
  {
    "id": "redundant_closure_call",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Detects closures called in the same expression where they\nare defined.",
      "Why is this bad": "It is unnecessarily adding to the expression's\ncomplexity.",
      "Known problems": "None.",
      "Example": "```rust\n(|| 42)()\n```"
    }
  },
  {
    "id": "double_neg",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Detects expressions of the form `--x`.",
      "Why is this bad": "It can mislead C/C++ programmers to think `x` was\ndecremented.",
      "Known problems": "None.",
      "Example": "```rust\nlet mut x = 3;\n--x;\n```"
    }
  },
  {
    "id": "mixed_case_hex_literals",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Warns on hexadecimal literals with mixed-case letter\ndigits.",
      "Why is this bad": "It looks confusing.",
      "Known problems": "None.",
      "Example": "```rust\nlet y = 0x1a9BAcD;\n```"
    }
  },
  {
    "id": "unseparated_literal_suffix",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Warns if literal suffixes are not separated by an\nunderscore.",
      "Why is this bad": "It is much less readable.",
      "Known problems": "None.",
      "Example": "```rust\nlet y = 123832i32;\n```"
    }
  },
  {
    "id": "zero_prefixed_literal",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Warns if an integral constant literal starts with `0`.",
      "Why is this bad": "In some languages (including the infamous C language\nand most of its\nfamily), this marks an octal constant. In Rust however, this is a decimal\nconstant. This could\nbe confusing for both the writer and a reader of the constant.",
      "Known problems": "None.",
      "Example": "In Rust:\n```rust\nfn main() {\n    let a = 0123;\n    println!(\"{}\", a);\n}\n```\nprints `123`, while in C:\n```c\n#include <stdio.h>\nint main() {\n    int a = 0123;\n    printf(\"%d\\n\", a);\n}\n```\nprints `83` (as `83 == 0o123` while `123 == 0o173`)."
    }
  },
  {
    "id": "builtin_type_shadow",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Warns if a generic shadows a built-in type.",
      "Why is this bad": "This gives surprising type errors.",
      "Known problems": "None.",
      "Example": "```ignore\nimpl<u32> Foo<u32> {\n    fn impl_func(&self) -> u32 {\n        42\n    }\n}\n```"
    }
  },
  {
    "id": "missing_const_for_fn",
    "group": "nursery",
    "level": "Allow",
    "docs": {
      "What it does": "Suggests the use of `const` in functions and methods where possible.",
      "Why is this bad": "Not having the function const prevents callers of the function from being const as well.",
      "Known problems": "Const functions are currently still being worked on, with some features only being available\non nightly. This lint does not consider all edge cases currently and the suggestions may be\nincorrect if you are using this lint on stable.\nAlso, the lint only runs one pass over the code. Consider these two non-const functions:\n```rust\nfn a() -> i32 {\n    0\n}\nfn b() -> i32 {\n    a()\n}\n```\nWhen running Clippy, the lint will only suggest to make `a` const, because `b` at this time\ncan't be const as it calls a non-const function. Making `a` const and running Clippy again,\nwill suggest to make `b` const, too.",
      "Example": "```rust\nfn new() -> Self {\n    Self { random_number: 42 }\n}\n```\nCould be a const fn:\n```rust\nconst fn new() -> Self {\n    Self { random_number: 42 }\n}\n```"
    }
  },
  {
    "id": "missing_docs_in_private_items",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Warns if there is missing doc for any documentable item\n(public or private).",
      "Why is this bad": "Doc is good. *rustc* has a `MISSING_DOCS`\nallowed-by-default lint for\npublic members, but has no way to enforce documentation of private items.\nThis lint fixes that.",
      "Known problems": "None."
    }
  },
  {
    "id": "missing_inline_in_public_items",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "it lints if an exported function, method, trait method with default impl,\nor trait method impl is not `#[inline]`.",
      "Why is this bad": "In general, it is not. Functions can be inlined across\ncrates when that's profitable as long as any form of LTO is used. When LTO is disabled,\nfunctions that are not `#[inline]` cannot be inlined across crates. Certain types of crates\nmight intend for most of the methods in their public API to be able to be inlined across\ncrates even when LTO is disabled. For these types of crates, enabling this lint might make\nsense. It allows the crate to require all exported methods to be `#[inline]` by default, and\nthen opt out for specific methods where this might not make sense.",
      "Known problems": "None.",
      "Example": "```rust\npub fn foo() {} // missing #[inline]\nfn ok() {} // ok\n#[inline] pub fn bar() {} // ok\n#[inline(always)] pub fn baz() {} // ok\npub trait Bar {\n  fn bar(); // ok\n  fn def_bar() {} // missing #[inline]\n}\nstruct Baz;\nimpl Baz {\n   fn priv() {} // ok\n}\nimpl Bar for Baz {\n  fn bar() {} // ok - Baz is not exported\n}\npub struct PubBaz;\nimpl PubBaz {\n   fn priv() {} // ok\n   pub not_ptriv() {} // missing #[inline]\n}\nimpl Bar for PubBaz {\n   fn bar() {} // missing #[inline]\n   fn def_bar() {} // missing #[inline]\n}\n```"
    }
  },
  {
    "id": "multiple_crate_versions",
    "group": "cargo",
    "level": "Allow",
    "docs": {
      "What it does": "Checks to see if multiple versions of a crate are being\nused.",
      "Why is this bad": "This bloats the size of targets, and can lead to\nconfusing error messages when structs or traits are used interchangeably\nbetween different versions of a crate.",
      "Known problems": "Because this can be caused purely by the dependencies\nthemselves, it's not always possible to fix this issue.",
      "Example": "```toml\n# This will pull in both winapi v0.3.4 and v0.2.8, triggering a warning.\n[dependencies]\nctrlc = \"3.1.0\"\nansi_term = \"0.11.0\"\n```"
    }
  },
  {
    "id": "mut_mut",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for instances of `mut mut` references.",
      "Why is this bad": "Multiple `mut`s don't add anything meaningful to the\nsource. This is either a copy'n'paste error, or it shows a fundamental\nmisunderstanding of references.",
      "Known problems": "None.",
      "Example": "```rust\nlet x = &mut &mut y;\n```"
    }
  },
  {
    "id": "unnecessary_mut_passed",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Detects giving a mutable reference to a function that only\nrequires an immutable reference.",
      "Why is this bad": "The immutable reference rules out all other references\nto the value. Also the code misleads about the intent of the call site.",
      "Known problems": "None.",
      "Example": "```ignore\nmy_vec.push(&mut value)\n```"
    }
  },
  {
    "id": "mutex_atomic",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usages of `Mutex<X>` where an atomic will do.",
      "Why is this bad": "Using a mutex just to make access to a plain bool or\nreference sequential is shooting flies with cannons.\n`std::sync::atomic::AtomicBool` and `std::sync::atomic::AtomicPtr` are leaner and\nfaster.",
      "Known problems": "This lint cannot detect if the mutex is actually used\nfor waiting before a critical section.",
      "Example": "```rust\nlet x = Mutex::new(&y);\n```"
    }
  },
  {
    "id": "mutex_integer",
    "group": "nursery",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usages of `Mutex<X>` where `X` is an integral\ntype.",
      "Why is this bad": "Using a mutex just to make access to a plain integer\nsequential is\nshooting flies with cannons. `std::sync::atomic::AtomicUsize` is leaner and faster.",
      "Known problems": "This lint cannot detect if the mutex is actually used\nfor waiting before a critical section.",
      "Example": "```rust\nlet x = Mutex::new(0usize);\n```"
    }
  },
  {
    "id": "needless_bool",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for expressions of the form `if c { true } else {\nfalse }`\n(or vice versa) and suggest using the condition directly.",
      "Why is this bad": "Redundant code.",
      "Known problems": "Maybe false positives: Sometimes, the two branches are\npainstakingly documented (which we, of course, do not detect), so they *may*\nhave some value. Even then, the documentation can be rewritten to match the\nshorter code.",
      "Example": "```rust\nif x {\n    false\n} else {\n    true\n}\n```"
    }
  },
  {
    "id": "bool_comparison",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for expressions of the form `x == true`,\n`x != true` and order comparisons such as `x < true` (or vice versa) and\nsuggest using the variable directly.",
      "Why is this bad": "Unnecessary code.",
      "Known problems": "None.",
      "Example": "```rust\nif x == true {} // could be `if x { }`\n```"
    }
  },
  {
    "id": "needless_borrow",
    "group": "nursery",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for address of operations (`&`) that are going to\nbe dereferenced immediately by the compiler.",
      "Why is this bad": "Suggests that the receiver of the expression borrows\nthe expression.",
      "Example": "```rust\nlet x: &i32 = &&&&&&5;\n```",
      "Known problems": "None."
    }
  },
  {
    "id": "needless_borrowed_reference",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for useless borrowed references.",
      "Why is this bad": "It is mostly useless and make the code look more\ncomplex than it\nactually is.",
      "Known problems": "It seems that the `&ref` pattern is sometimes useful.\nFor instance in the following snippet:\n```rust\nenum Animal {\n    Cat(u64),\n    Dog(u64),\n}\nfn foo(a: &Animal, b: &Animal) {\n    match (a, b) {\n(&Animal::Cat(v), k) | (k, &Animal::Cat(v)) => (), // lifetime\nmismatch error\n        (&Animal::Dog(ref c), &Animal::Dog(_)) => ()\n    }\n}\n```\nThere is a lifetime mismatch error for `k` (indeed a and b have distinct\nlifetime).\nThis can be fixed by using the `&ref` pattern.\nHowever, the code can also be fixed by much cleaner ways",
      "Example": "```rust\nlet mut v = Vec::<String>::new();\nlet _ = v.iter_mut().filter(|&ref a| a.is_empty());\n```\nThis closure takes a reference on something that has been matched as a\nreference and\nde-referenced.\nAs such, it could just be |a| a.is_empty()"
    }
  },
  {
    "id": "needless_continue",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "The lint checks for `if`-statements appearing in loops\nthat contain a `continue` statement in either their main blocks or their\n`else`-blocks, when omitting the `else`-block possibly with some\nrearrangement of code can make the code easier to understand.",
      "Why is this bad": "Having explicit `else` blocks for `if` statements\ncontaining `continue` in their THEN branch adds unnecessary branching and\nnesting to the code. Having an else block containing just `continue` can\nalso be better written by grouping the statements following the whole `if`\nstatement within the THEN block and omitting the else block completely.",
      "Known problems": "None",
      "Example": "```rust\nwhile condition() {\n    update_condition();\n    if x {\n        // ...\n    } else {\n        continue;\n    }\n    println!(\"Hello, world\");\n}\n```\nCould be rewritten as\n```rust\nwhile condition() {\n    update_condition();\n    if x {\n        // ...\n        println!(\"Hello, world\");\n    }\n}\n```\nAs another example, the following code\n```rust\nloop {\n    if waiting() {\n        continue;\n    } else {\n        // Do something useful\n    }\n}\n```\nCould be rewritten as\n```rust\nloop {\n    if waiting() {\n        continue;\n    }\n    // Do something useful\n}\n```"
    }
  },
  {
    "id": "needless_pass_by_value",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for functions taking arguments by value, but not\nconsuming them in its\nbody.",
      "Why is this bad": "Taking arguments by reference is more flexible and can\nsometimes avoid\nunnecessary allocations.",
      "Known problems": "* This lint suggests taking an argument by reference,\nhowever sometimes it is better to let users decide the argument type\n(by using `Borrow` trait, for example), depending on how the function is used.",
      "Example": "```rust\nfn foo(v: Vec<i32>) {\n    assert_eq!(v.len(), 42);\n}\n// should be\nfn foo(v: &[i32]) {\n    assert_eq!(v.len(), 42);\n}\n```"
    }
  },
  {
    "id": "needless_update",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for needlessly including a base struct on update\nwhen all fields are changed anyway.",
      "Why is this bad": "This will cost resources (because the base has to be\nsomewhere), and make the code less readable.",
      "Known problems": "None.",
      "Example": "```rust\nPoint {\n    x: 1,\n    y: 0,\n    ..zero_point\n}\n```"
    }
  },
  {
    "id": "neg_cmp_op_on_partial_ord",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for the usage of negated comparison operators on types which only implement\n`PartialOrd` (e.g., `f64`).",
      "Why is this bad": "These operators make it easy to forget that the underlying types actually allow not only three\npotential Orderings (Less, Equal, Greater) but also a fourth one (Uncomparable). This is\nespecially easy to miss if the operator based comparison result is negated.",
      "Known problems": "None.",
      "Example": "```rust\nuse std::cmp::Ordering;\n// Bad\nlet a = 1.0;\nlet b = std::f64::NAN;\nlet _not_less_or_equal = !(a <= b);\n// Good\nlet a = 1.0;\nlet b = std::f64::NAN;\nlet _not_less_or_equal = match a.partial_cmp(&b) {\n    None | Some(Ordering::Greater) => true,\n    _ => false,\n};\n```"
    }
  },
  {
    "id": "neg_multiply",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for multiplication by -1 as a form of negation.",
      "Why is this bad": "It's more readable to just negate.",
      "Known problems": "This only catches integers (for now).",
      "Example": "```ignore\nx * -1\n```"
    }
  },
  {
    "id": "new_without_default",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for types with a `fn new() -> Self` method and no\nimplementation of\n[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html).\nIt detects both the case when a manual\n[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\nimplementation is required and also when it can be created with\n`#[derive(Default)]`",
      "Why is this bad": "The user might expect to be able to use\n[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) as the\ntype can be constructed without arguments.",
      "Known problems": "Hopefully none.",
      "Example": "```ignore\nstruct Foo(Bar);\nimpl Foo {\n    fn new() -> Self {\n        Foo(Bar::new())\n    }\n}\n```\nInstead, use:\n```ignore\nstruct Foo(Bar);\nimpl Default for Foo {\n    fn default() -> Self {\n        Foo(Bar::new())\n    }\n}\n```\nOr, if\n[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\ncan be derived by `#[derive(Default)]`:\n```rust\nstruct Foo;\nimpl Foo {\n    fn new() -> Self {\n        Foo\n    }\n}\n```\nInstead, use:\n```rust\n#[derive(Default)]\nstruct Foo;\nimpl Foo {\n    fn new() -> Self {\n        Foo\n    }\n}\n```\nYou can also have `new()` call `Default::default()`."
    }
  },
  {
    "id": "no_effect",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for statements which have no effect.",
      "Why is this bad": "Similar to dead code, these statements are actually\nexecuted. However, as they have no effect, all they do is make the code less\nreadable.",
      "Known problems": "None.",
      "Example": "```rust\n0;\n```"
    }
  },
  {
    "id": "unnecessary_operation",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for expression statements that can be reduced to a\nsub-expression.",
      "Why is this bad": "Expressions by themselves often have no side-effects.\nHaving such expressions reduces readability.",
      "Known problems": "None.",
      "Example": "```rust\ncompute_array()[0];\n```"
    }
  },
  {
    "id": "declare_interior_mutable_const",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for declaration of `const` items which is interior\nmutable (e.g., contains a `Cell`, `Mutex`, `AtomicXxxx`, etc.).",
      "Why is this bad": "Consts are copied everywhere they are referenced, i.e.,\nevery time you refer to the const a fresh instance of the `Cell` or `Mutex`\nor `AtomicXxxx` will be created, which defeats the whole purpose of using\nthese types in the first place.\nThe `const` should better be replaced by a `static` item if a global\nvariable is wanted, or replaced by a `const fn` if a constructor is wanted.",
      "Known problems": "A \"non-constant\" const item is a legacy way to supply an\ninitialized value to downstream `static` items (e.g., the\n`std::sync::ONCE_INIT` constant). In this case the use of `const` is legit,\nand this lint should be suppressed.",
      "Example": "```rust\nuse std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n// Bad.\nconst CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\nCONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\nassert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n// Good.\nstatic STATIC_ATOM: AtomicUsize = AtomicUsize::new(15);\nSTATIC_ATOM.store(9, SeqCst);\nassert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n```"
    }
  },
  {
    "id": "borrow_interior_mutable_const",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks if `const` items which is interior mutable (e.g.,\ncontains a `Cell`, `Mutex`, `AtomicXxxx`, etc.) has been borrowed directly.",
      "Why is this bad": "Consts are copied everywhere they are referenced, i.e.,\nevery time you refer to the const a fresh instance of the `Cell` or `Mutex`\nor `AtomicXxxx` will be created, which defeats the whole purpose of using\nthese types in the first place.\nThe `const` value should be stored inside a `static` item.",
      "Known problems": "None",
      "Example": "```rust\nuse std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\nconst CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n// Bad.\nCONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\nassert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n// Good.\nstatic STATIC_ATOM: AtomicUsize = CONST_ATOM;\nSTATIC_ATOM.store(9, SeqCst);\nassert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n```"
    }
  },
  {
    "id": "similar_names",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for names that are very similar and thus confusing.",
      "Why is this bad": "It's hard to distinguish between names that differ only\nby a single character.",
      "Known problems": "None?",
      "Example": "```ignore\nlet checked_exp = something;\nlet checked_expr = something_else;\n```"
    }
  },
  {
    "id": "many_single_char_names",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for too many variables whose name consists of a\nsingle character.",
      "Why is this bad": "It's hard to memorize what a variable means without a\ndescriptive name.",
      "Known problems": "None?",
      "Example": "```ignore\nlet (a, b, c, d, e, f, g) = (...);\n```",
      "Configuration": "This lint has the following configuration variables:\n\n* `single-char-binding-names-threshold: u64`: The maximum number of single char bindings a scope may have (defaults to `5 `)."
    }
  },
  {
    "id": "just_underscores_and_digits",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks if you have variables whose name consists of just\nunderscores and digits.",
      "Why is this bad": "It's hard to memorize what a variable means without a\ndescriptive name.",
      "Known problems": "None?",
      "Example": "```rust\nlet _1 = 1;\nlet ___1 = 1;\nlet __1___2 = 11;\n```"
    }
  },
  {
    "id": "if_let_some_result",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "* Checks for unnecessary `ok()` in if let.",
      "Why is this bad": "Calling `ok()` in if let is unnecessary, instead match\non `Ok(pat)`",
      "Known problems": "None.",
      "Example": "```ignore\nfor result in iter {\n    if let Some(bench) = try!(result).parse().ok() {\n        vec.push(bench)\n    }\n}\n```\nCould be written:\n```ignore\nfor result in iter {\n    if let Ok(bench) = try!(result).parse() {\n        vec.push(bench)\n    }\n}\n```"
    }
  },
  {
    "id": "nonsensical_open_options",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for duplicate open options as well as combinations\nthat make no sense.",
      "Why is this bad": "In the best case, the code will be harder to read than\nnecessary. I don't know the worst case.",
      "Known problems": "None.",
      "Example": "```rust\nuse std::fs::OpenOptions;\nOpenOptions::new().read(true).truncate(true);\n```"
    }
  },
  {
    "id": "overflow_check_conditional",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Detects classic underflow/overflow checks.",
      "Why is this bad": "Most classic C underflow/overflow checks will fail in\nRust. Users can use functions like `overflowing_*` and `wrapping_*` instead.",
      "Known problems": "None.",
      "Example": "```rust\na + b < a\n```"
    }
  },
  {
    "id": "panic_params",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for missing parameters in `panic!`.",
      "Why is this bad": "Contrary to the `format!` family of macros, there are\ntwo forms of `panic!`: if there are no parameters given, the first argument\nis not a format string and used literally. So while `format!(\"{}\")` will\nfail to compile, `panic!(\"{}\")` will not.",
      "Known problems": "None.",
      "Example": "```no_run\npanic!(\"This `panic!` is probably missing a parameter there: {}\");\n```"
    }
  },
  {
    "id": "unimplemented",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usage of `unimplemented!`.",
      "Why is this bad": "This macro should not be present in production code",
      "Known problems": "None.",
      "Example": "```no_run\nunimplemented!();\n```"
    }
  },
  {
    "id": "partialeq_ne_impl",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for manual re-implementations of `PartialEq::ne`.",
      "Why is this bad": "`PartialEq::ne` is required to always return the\nnegated result of `PartialEq::eq`, which is exactly what the default\nimplementation does. Therefore, there should never be any need to\nre-implement it.",
      "Known problems": "None.",
      "Example": "```rust\nstruct Foo;\nimpl PartialEq for Foo {\n   fn eq(&self, other: &Foo) -> bool { ... }\n   fn ne(&self, other: &Foo) -> bool { !(self == other) }\n}\n```"
    }
  },
  {
    "id": "path_buf_push_overwrite",
    "group": "nursery",
    "level": "Allow",
    "docs": {
      "What it does": "* Checks for [push](https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.push)\ncalls on `PathBuf` that can cause overwrites.",
      "Why is this bad": "Calling `push` with a root path at the start can overwrite the\nprevious defined path.",
      "Known problems": "None.",
      "Example": "```rust\nuse std::path::PathBuf;\nlet mut x = PathBuf::from(\"/foo\");\nx.push(\"/bar\");\nassert_eq!(x, PathBuf::from(\"/bar\"));\n```\nCould be written:\n```rust\nuse std::path::PathBuf;\nlet mut x = PathBuf::from(\"/foo\");\nx.push(\"bar\");\nassert_eq!(x, PathBuf::from(\"/foo/bar\"));\n```"
    }
  },
  {
    "id": "precedence",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for operations where precedence may be unclear\nand suggests to add parentheses. Currently it catches the following:\n* mixed usage of arithmetic and bit shifting/combining operators without\nparentheses\n* a \"negative\" numeric literal (which is really a unary `-` followed by a\nnumeric literal)\n  followed by a method call",
      "Why is this bad": "Not everyone knows the precedence of those operators by\nheart, so expressions like these may trip others trying to reason about the\ncode.",
      "Known problems": "None.",
      "Example": "* `1 << 2 + 3` equals 32, while `(1 << 2) + 3` equals 7\n* `-1i32.abs()` equals -1, while `(-1i32).abs()` equals 1"
    }
  },
  {
    "id": "ptr_arg",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "This lint checks for function arguments of type `&String`\nor `&Vec` unless the references are mutable. It will also suggest you\nreplace `.clone()` calls with the appropriate `.to_owned()`/`to_string()`\ncalls.",
      "Why is this bad": "Requiring the argument to be of the specific size\nmakes the function less useful for no benefit; slices in the form of `&[T]`\nor `&str` usually suffice and can be obtained from other types, too.",
      "Known problems": "The lint does not follow data. So if you have an\nargument `x` and write `let y = x; y.clone()` the lint will not suggest\nchanging that `.clone()` to `.to_owned()`.\nOther functions called from this function taking a `&String` or `&Vec`\nargument may also fail to compile if you change the argument. Applying\nthis lint on them will fix the problem, but they may be in other crates.\nAlso there may be `fn(&Vec)`-typed references pointing to your function.\nIf you have them, you will get a compiler error after applying this lint's\nsuggestions. You then have the choice to undo your changes or change the\ntype of the reference.\nNote that if the function is part of your public interface, there may be\nother crates referencing it you may not be aware. Carefully deprecate the\nfunction before applying the lint suggestions in this case.",
      "Example": "```ignore\nfn foo(&Vec<u32>) { .. }\n```"
    }
  },
  {
    "id": "cmp_null",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "This lint checks for equality comparisons with `ptr::null`",
      "Why is this bad": "It's easier and more readable to use the inherent\n`.is_null()`\nmethod instead",
      "Known problems": "None.",
      "Example": "```ignore\nif x == ptr::null {\n    ..\n}\n```"
    }
  },
  {
    "id": "mut_from_ref",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "This lint checks for functions that take immutable\nreferences and return\nmutable ones.",
      "Why is this bad": "This is trivially unsound, as one can create two\nmutable references\nfrom the same (immutable!) source. This\n[error](https://github.com/rust-lang/rust/issues/39465)\nactually lead to an interim Rust release 1.15.1.",
      "Known problems": "To be on the conservative side, if there's at least one\nmutable reference\nwith the output lifetime, this lint will not trigger. In practice, this\ncase is unlikely anyway.",
      "Example": "```ignore\nfn foo(&Foo) -> &mut Bar { .. }\n```"
    }
  },
  {
    "id": "ptr_offset_with_cast",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of the `offset` pointer method with a `usize` casted to an\n`isize`.",
      "Why is this bad": "If we\u2019re always increasing the pointer address, we can avoid the numeric\ncast by using the `add` method instead.",
      "Known problems": "None",
      "Example": "```rust\nlet vec = vec![b'a', b'b', b'c'];\nlet ptr = vec.as_ptr();\nlet offset = 1_usize;\nunsafe {\n    ptr.offset(offset as isize);\n}\n```\nCould be written:\n```rust\nlet vec = vec![b'a', b'b', b'c'];\nlet ptr = vec.as_ptr();\nlet offset = 1_usize;\nunsafe {\n    ptr.add(offset);\n}\n```"
    }
  },
  {
    "id": "question_mark",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for expressions that could be replaced by the question mark operator.",
      "Why is this bad": "Question mark usage is more idiomatic.",
      "Known problems": "None",
      "Example": "```ignore\nif option.is_none() {\n    return None;\n}\n```\nCould be written:\n```ignore\noption?;\n```"
    }
  },
  {
    "id": "iterator_step_by_zero",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for calling `.step_by(0)` on iterators,\nwhich never terminates.",
      "Why is this bad": "This very much looks like an oversight, since with\n`loop { .. }` there is an obvious better way to endlessly loop.",
      "Known problems": "None.",
      "Example": "```ignore\nfor x in (5..5).step_by(0) {\n    ..\n}\n```"
    }
  },
  {
    "id": "range_zip_with_len",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for zipping a collection with the range of\n`0.._.len()`.",
      "Why is this bad": "The code is better expressed with `.enumerate()`.",
      "Known problems": "None.",
      "Example": "```rust\nx.iter().zip(0..x.len())\n```"
    }
  },
  {
    "id": "range_plus_one",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for exclusive ranges where 1 is added to the\nupper bound, e.g., `x..(y+1)`.",
      "Why is this bad": "The code is more readable with an inclusive range\nlike `x..=y`.",
      "Known problems": "Will add unnecessary pair of parentheses when the\nexpression is not wrapped in a pair but starts with a opening parenthesis\nand ends with a closing one.\nI.e., `let _ = (f()+1)..(f()+1)` results in `let _ = ((f()+1)..=f())`.",
      "Example": "```rust\nfor x..(y+1) { .. }\n```"
    }
  },
  {
    "id": "range_minus_one",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for inclusive ranges where 1 is subtracted from\nthe upper bound, e.g., `x..=(y-1)`.",
      "Why is this bad": "The code is more readable with an exclusive range\nlike `x..y`.",
      "Known problems": "None.",
      "Example": "```rust\nfor x..=(y-1) { .. }\n```"
    }
  },
  {
    "id": "redundant_clone",
    "group": "nursery",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for a redudant `clone()` (and its relatives) which clones an owned\nvalue that is going to be dropped without further use.",
      "Why is this bad": "It is not always possible for the compiler to eliminate useless\nallocations and deallocations generated by redundant `clone()`s.",
      "Known problems": "* Suggestions made by this lint could require NLL to be enabled.\n* False-positive if there is a borrow preventing the value from moving out.\n```rust\nlet x = String::new();\nlet y = &x;\nfoo(x.clone()); // This lint suggests to remove this `clone()`\n```",
      "Example": "```rust\n{\n    let x = Foo::new();\n    call(x.clone());\n    call(x.clone()); // this can just pass `x`\n}\n[\"lorem\", \"ipsum\"].join(\" \").to_string()\nPath::new(\"/a/b\").join(\"c\").to_path_buf()\n```"
    }
  },
  {
    "id": "redundant_field_names",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for fields in struct literals where shorthands\ncould be used.",
      "Why is this bad": "If the field and variable names are the same,\nthe field name is redundant.",
      "Known problems": "None.",
      "Example": "```rust\nlet bar: u8 = 123;\nstruct Foo {\n    bar: u8,\n}\nlet foo = Foo { bar: bar };\n```\nthe last line can be simplified to\n```ignore\nlet foo = Foo { bar };\n```"
    }
  },
  {
    "id": "redundant_pattern_matching",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Lint for redundant pattern matching over `Result` or\n`Option`",
      "Why is this bad": "It's more concise and clear to just use the proper\nutility function",
      "Known problems": "None.",
      "Example": "```rust\nif let Ok(_) = Ok::<i32, i32>(42) {}\nif let Err(_) = Err::<i32, i32>(42) {}\nif let None = None::<()> {}\nif let Some(_) = Some(42) {}\nmatch Ok::<i32, i32>(42) {\n    Ok(_) => true,\n    Err(_) => false,\n};\n```\nThe more idiomatic use would be:\n```rust\nif Ok::<i32, i32>(42).is_ok() {}\nif Err::<i32, i32>(42).is_err() {}\nif None::<()>.is_none() {}\nif Some(42).is_some() {}\nOk::<i32, i32>(42).is_ok();\n```"
    }
  },
  {
    "id": "redundant_static_lifetimes",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for constants and statics with an explicit `'static` lifetime.",
      "Why is this bad": "Adding `'static` to every reference can create very\ncomplicated types.",
      "Known problems": "None.",
      "Example": "```ignore\nconst FOO: &'static [(&'static str, &'static str, fn(&Bar) -> bool)] =\n&[...]\nstatic FOO: &'static [(&'static str, &'static str, fn(&Bar) -> bool)] =\n&[...]\n```\nThis code can be rewritten as\n```ignore\n const FOO: &[(&str, &str, fn(&Bar) -> bool)] = &[...]\n static FOO: &[(&str, &str, fn(&Bar) -> bool)] = &[...]\n```"
    }
  },
  {
    "id": "deref_addrof",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of `*&` and `*&mut` in expressions.",
      "Why is this bad": "Immediately dereferencing a reference is no-op and\nmakes the code less clear.",
      "Known problems": "Multiple dereference/addrof pairs are not handled so\nthe suggested fix for `x = **&&y` is `x = *&y`, which is still incorrect.",
      "Example": "```rust\nlet a = f(*&mut b);\nlet c = *&d;\n```"
    }
  },
  {
    "id": "ref_in_deref",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for references in expressions that use\nauto dereference.",
      "Why is this bad": "The reference is a no-op and is automatically\ndereferenced by the compiler and makes the code less clear.",
      "Example": "```rust\nstruct Point(u32, u32);\nlet point = Foo(30, 20);\nlet x = (&point).x;\n```"
    }
  },
  {
    "id": "invalid_regex",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks [regex](https://crates.io/crates/regex) creation\n(with `Regex::new`,`RegexBuilder::new` or `RegexSet::new`) for correct\nregex syntax.",
      "Why is this bad": "This will lead to a runtime panic.",
      "Known problems": "None.",
      "Example": "```ignore\nRegex::new(\"|\")\n```"
    }
  },
  {
    "id": "trivial_regex",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for trivial [regex](https://crates.io/crates/regex)\ncreation (with `Regex::new`, `RegexBuilder::new` or `RegexSet::new`).",
      "Why is this bad": "Matching the regex can likely be replaced by `==` or\n`str::starts_with`, `str::ends_with` or `std::contains` or other `str`\nmethods.",
      "Known problems": "None.",
      "Example": "```ignore\nRegex::new(\"^foobar\")\n```"
    }
  },
  {
    "id": "regex_macro",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of `regex!(_)` which (as of now) is\nusually slower than `Regex::new(_)` unless called in a loop (which is a bad\nidea anyway).",
      "Why is this bad": "Performance, at least for now. The macro version is\nlikely to catch up long-term, but for now the dynamic version is faster.",
      "Known problems": "None.",
      "Example": "```ignore\nregex!(\"foo|bar\")\n```"
    }
  },
  {
    "id": "replace_consts",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usage of `ATOMIC_X_INIT`, `ONCE_INIT`, and\n`uX/iX::MIN/MAX`.",
      "Why is this bad": "`const fn`s exist",
      "Known problems": "None.",
      "Example": "```rust\nstatic FOO: AtomicIsize = ATOMIC_ISIZE_INIT;\n```\nCould be written:\n```rust\nstatic FOO: AtomicIsize = AtomicIsize::new(0);\n```"
    }
  },
  {
    "id": "needless_return",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for return statements at the end of a block.",
      "Why is this bad": "Removing the `return` and semicolon will make the code\nmore rusty.",
      "Known problems": "If the computation returning the value borrows a local\nvariable, removing the `return` may run afoul of the borrow checker.",
      "Example": "```rust\nfn foo(x: usize) -> usize {\n    return x;\n}\n```\nsimplify to\n```rust\nfn foo(x: usize) -> usize {\n    x\n}\n```"
    }
  },
  {
    "id": "let_and_return",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for `let`-bindings, which are subsequently\nreturned.",
      "Why is this bad": "It is just extraneous code. Remove it to make your code\nmore rusty.",
      "Known problems": "None.",
      "Example": "```rust\nfn foo() -> String {\n    let x = String::new();\n    x\n}\n```\ninstead, use\n```\nfn foo() -> String {\n    String::new()\n}\n```"
    }
  },
  {
    "id": "unused_unit",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for unit (`()`) expressions that can be removed.",
      "Why is this bad": "Such expressions add no value, but can make the code\nless readable. Depending on formatting they can make a `break` or `return`\nstatement look like a function call.",
      "Known problems": "The lint currently misses unit return types in types,\ne.g., the `F` in `fn generic_unit<F: Fn() -> ()>(f: F) { .. }`.",
      "Example": "```rust\nfn return_unit() -> () {\n    ()\n}\n```"
    }
  },
  {
    "id": "serde_api_misuse",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for mis-uses of the serde API.",
      "Why is this bad": "Serde is very finnicky about how its API should be\nused, but the type system can't be used to enforce it (yet?).",
      "Known problems": "None.",
      "Example": "Implementing `Visitor::visit_string` but not\n`Visitor::visit_str`."
    }
  },
  {
    "id": "shadow_same",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for bindings that shadow other bindings already in\nscope, while just changing reference level or mutability.",
      "Why is this bad": "Not much, in fact it's a very common pattern in Rust\ncode. Still, some may opt to avoid it in their code base, they can set this\nlint to `Warn`.",
      "Known problems": "This lint, as the other shadowing related lints,\ncurrently only catches very simple patterns.",
      "Example": "```rust\nlet x = &x;\n```"
    }
  },
  {
    "id": "shadow_reuse",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for bindings that shadow other bindings already in\nscope, while reusing the original value.",
      "Why is this bad": "Not too much, in fact it's a common pattern in Rust\ncode. Still, some argue that name shadowing like this hurts readability,\nbecause a value may be bound to different things depending on position in\nthe code.",
      "Known problems": "This lint, as the other shadowing related lints,\ncurrently only catches very simple patterns.",
      "Example": "```rust\nlet x = x + 1;\n```\nuse different variable name:\n```rust\nlet y = x + 1;\n```"
    }
  },
  {
    "id": "shadow_unrelated",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for bindings that shadow other bindings already in\nscope, either without a initialization or with one that does not even use\nthe original value.",
      "Why is this bad": "Name shadowing can hurt readability, especially in\nlarge code bases, because it is easy to lose track of the active binding at\nany place in the code. This can be alleviated by either giving more specific\nnames to bindings or introducing more scopes to contain the bindings.",
      "Known problems": "This lint, as the other shadowing related lints,\ncurrently only catches very simple patterns.",
      "Example": "```rust\nlet x = y;\nlet x = z; // shadows the earlier binding\n```"
    }
  },
  {
    "id": "slow_vector_initialization",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks slow zero-filled vector initialization",
      "Why is this bad": "These structures are non-idiomatic and less efficient than simply using\n`vec![0; len]`.",
      "Known problems": "None.",
      "Example": "```rust\nlet mut vec1 = Vec::with_capacity(len);\nvec1.resize(len, 0);\nlet mut vec2 = Vec::with_capacity(len);\nvec2.extend(repeat(0).take(len))\n```"
    }
  },
  {
    "id": "string_add_assign",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for string appends of the form `x = x + y` (without\n`let`!).",
      "Why is this bad": "It's not really bad, but some people think that the\n`.push_str(_)` method is more readable.",
      "Known problems": "None.",
      "Example": "```rust\nlet mut x = \"Hello\".to_owned();\nx = x + \", World\";\n```"
    }
  },
  {
    "id": "string_add",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for all instances of `x + _` where `x` is of type\n`String`, but only if [`string_add_assign`](#string_add_assign) does *not*\nmatch.",
      "Why is this bad": "It's not bad in and of itself. However, this particular\n`Add` implementation is asymmetric (the other operand need not be `String`,\nbut `x` does), while addition as mathematically defined is symmetric, also\nthe `String::push_str(_)` function is a perfectly good replacement.\nTherefore, some dislike it and wish not to have it in their code.\nThat said, other people think that string addition, having a long tradition\nin other languages is actually fine, which is why we decided to make this\nparticular lint `allow` by default.",
      "Known problems": "None.",
      "Example": "```rust\nlet x = \"Hello\".to_owned();\nx + \", World\"\n```"
    }
  },
  {
    "id": "string_lit_as_bytes",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for the `as_bytes` method called on string literals\nthat contain only ASCII characters.",
      "Why is this bad": "Byte string literals (e.g., `b\"foo\"`) can be used\ninstead. They are shorter but less discoverable than `as_bytes()`.",
      "Known Problems": "None.",
      "Example": "```rust\nlet bs = \"a byte string\".as_bytes();\n```"
    }
  },
  {
    "id": "suspicious_arithmetic_impl",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Lints for suspicious operations in impls of arithmetic operators, e.g.\nsubtracting elements in an Add impl.",
      "Why this is bad": "This is probably a typo or copy-and-paste error and not intended.",
      "Known problems": "None.",
      "Example": "```ignore\nimpl Add for Foo {\n    type Output = Foo;\n    fn add(self, other: Foo) -> Foo {\n        Foo(self.0 - other.0)\n    }\n}\n```"
    }
  },
  {
    "id": "suspicious_op_assign_impl",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Lints for suspicious operations in impls of OpAssign, e.g.\nsubtracting elements in an AddAssign impl.",
      "Why this is bad": "This is probably a typo or copy-and-paste error and not intended.",
      "Known problems": "None.",
      "Example": "```ignore\nimpl AddAssign for Foo {\n    fn add_assign(&mut self, other: Foo) {\n        *self = *self - other;\n    }\n}\n```"
    }
  },
  {
    "id": "manual_swap",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for manual swapping.",
      "Why is this bad": "The `std::mem::swap` function exposes the intent better\nwithout deinitializing or copying either variable.",
      "Known problems": "None.",
      "Example": "```rust\nlet t = b;\nb = a;\na = t;\n```\nUse std::mem::swap():\n```rust\nstd::mem::swap(&mut a, &mut b);\n```"
    }
  },
  {
    "id": "almost_swapped",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for `foo = bar; bar = foo` sequences.",
      "Why is this bad": "This looks like a failed attempt to swap.",
      "Known problems": "None.",
      "Example": "```rust\n# let mut a = 1;\n# let mut b = 2;\na = b;\nb = a;\n```"
    }
  },
  {
    "id": "temporary_assignment",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for construction of a structure or tuple just to\nassign a value in it.",
      "Why is this bad": "Readability. If the structure is only created to be\nupdated, why not write the structure you want in the first place?",
      "Known problems": "None.",
      "Example": "```rust\n(0, 0).0 = 1\n```"
    }
  },
  {
    "id": "wrong_transmute",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for transmutes that can't ever be correct on any\narchitecture.",
      "Why is this bad": "It's basically guaranteed to be undefined behaviour.",
      "Known problems": "When accessing C, users might want to store pointer\nsized objects in `extradata` arguments to save an allocation.",
      "Example": "```ignore\nlet ptr: *const T = core::intrinsics::transmute('x')\n```"
    }
  },
  {
    "id": "useless_transmute",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for transmutes to the original type of the object\nand transmutes that could be a cast.",
      "Why is this bad": "Readability. The code tricks people into thinking that\nsomething complex is going on.",
      "Known problems": "None.",
      "Example": "```rust\ncore::intrinsics::transmute(t) // where the result type is the same as `t`'s\n```"
    }
  },
  {
    "id": "crosspointer_transmute",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for transmutes between a type `T` and `*T`.",
      "Why is this bad": "It's easy to mistakenly transmute between a type and a\npointer to that type.",
      "Known problems": "None.",
      "Example": "```rust\ncore::intrinsics::transmute(t) // where the result type is the same as\n                               // `*t` or `&t`'s\n```"
    }
  },
  {
    "id": "transmute_ptr_to_ref",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for transmutes from a pointer to a reference.",
      "Why is this bad": "This can always be rewritten with `&` and `*`.",
      "Known problems": "None.",
      "Example": "```rust\nlet _: &T = std::mem::transmute(p); // where p: *const T\n// can be written:\nlet _: &T = &*p;\n```"
    }
  },
  {
    "id": "transmute_int_to_char",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for transmutes from an integer to a `char`.",
      "Why is this bad": "Not every integer is a Unicode scalar value.",
      "Known problems": "- [`from_u32`] which this lint suggests using is slower than `transmute`\nas it needs to validate the input.\nIf you are certain that the input is always a valid Unicode scalar value,\nuse [`from_u32_unchecked`] which is as fast as `transmute`\nbut has a semantically meaningful name.\n- You might want to handle `None` returned from [`from_u32`] instead of calling `unwrap`.\n[`from_u32`]: https://doc.rust-lang.org/std/char/fn.from_u32.html\n[`from_u32_unchecked`]: https://doc.rust-lang.org/std/char/fn.from_u32_unchecked.html",
      "Example": "```rust\nlet _: char = std::mem::transmute(x); // where x: u32\n// should be:\nlet _ = std::char::from_u32(x).unwrap();\n```"
    }
  },
  {
    "id": "transmute_bytes_to_str",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for transmutes from a `&[u8]` to a `&str`.",
      "Why is this bad": "Not every byte slice is a valid UTF-8 string.",
      "Known problems": "- [`from_utf8`] which this lint suggests using is slower than `transmute`\nas it needs to validate the input.\nIf you are certain that the input is always a valid UTF-8,\nuse [`from_utf8_unchecked`] which is as fast as `transmute`\nbut has a semantically meaningful name.\n- You might want to handle errors returned from [`from_utf8`] instead of calling `unwrap`.\n[`from_utf8`]: https://doc.rust-lang.org/std/str/fn.from_utf8.html\n[`from_utf8_unchecked`]: https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked.html",
      "Example": "```rust\nlet _: &str = std::mem::transmute(b); // where b: &[u8]\n// should be:\nlet _ = std::str::from_utf8(b).unwrap();\n```"
    }
  },
  {
    "id": "transmute_int_to_bool",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for transmutes from an integer to a `bool`.",
      "Why is this bad": "This might result in an invalid in-memory representation of a `bool`.",
      "Known problems": "None.",
      "Example": "```rust\nlet _: bool = std::mem::transmute(x); // where x: u8\n// should be:\nlet _: bool = x != 0;\n```"
    }
  },
  {
    "id": "transmute_int_to_float",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for transmutes from an integer to a float.",
      "Why is this bad": "Transmutes are dangerous and error-prone, whereas `from_bits` is intuitive\nand safe.",
      "Known problems": "None.",
      "Example": "```rust\nlet _: f32 = std::mem::transmute(x); // where x: u32\n// should be:\nlet _: f32 = f32::from_bits(x);\n```"
    }
  },
  {
    "id": "transmute_ptr_to_ptr",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for transmutes from a pointer to a pointer, or\nfrom a reference to a reference.",
      "Why is this bad": "Transmutes are dangerous, and these can instead be\nwritten as casts.",
      "Known problems": "None.",
      "Example": "```rust\nlet ptr = &1u32 as *const u32;\nunsafe {\n    // pointer-to-pointer transmute\n    let _: *const f32 = std::mem::transmute(ptr);\n    // ref-ref transmute\n    let _: &f32 = std::mem::transmute(&1u32);\n}\n// These can be respectively written:\nlet _ = ptr as *const f32\nlet _ = unsafe{ &*(&1u32 as *const u32 as *const f32) };\n```"
    }
  },
  {
    "id": "transmuting_null",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for transmute calls which would receive a null pointer.",
      "Why is this bad": "Transmuting a null pointer is undefined behavior.",
      "Known problems": "Not all cases can be detected at the moment of this writing.\nFor example, variables which hold a null pointer and are then fed to a `transmute`\ncall, aren't detectable yet.",
      "Example": "```rust\nlet null_ref: &u64 = unsafe { std::mem::transmute(0 as *const u64) };\n```"
    }
  },
  {
    "id": "trivially_copy_pass_by_ref",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for functions taking arguments by reference, where\nthe argument type is `Copy` and small enough to be more efficient to always\npass by value.",
      "Why is this bad": "In many calling conventions instances of structs will\nbe passed through registers if they fit into two or less general purpose\nregisters.",
      "Known problems": "This lint is target register size dependent, it is\nlimited to 32-bit to try and reduce portability problems between 32 and\n64-bit, but if you are compiling for 8 or 16-bit targets then the limit\nwill be different.\nThe configuration option `trivial_copy_size_limit` can be set to override\nthis limit for a project.\nThis lint attempts to allow passing arguments by reference if a reference\nto that argument is returned. This is implemented by comparing the lifetime\nof the argument and return value for equality. However, this can cause\nfalse positives in cases involving multiple lifetimes that are bounded by\neach other.",
      "Example": "```rust\nfn foo(v: &u32) {\n    assert_eq!(v, 42);\n}\n// should be\nfn foo(v: u32) {\n    assert_eq!(v, 42);\n}\n```",
      "Configuration": "This lint has the following configuration variables:\n\n* `trivial-copy-size-limit: Option<u64>`: The maximum size (in bytes) to consider a `Copy` type for passing by value instead of by reference. (defaults to `None `)."
    }
  },
  {
    "id": "try_err",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usages of `Err(x)?`.",
      "Why is this bad": "The `?` operator is designed to allow calls that\ncan fail to be easily chained. For example, `foo()?.bar()` or\n`foo(bar()?)`. Because `Err(x)?` can't be used that way (it will\nalways return), it is more clear to write `return Err(x)`.",
      "Known problems": "None.",
      "Example": "```rust\nfn foo(fail: bool) -> Result<i32, String> {\n    if fail {\n      Err(\"failed\")?;\n    }\n    Ok(0)\n}\n```\nCould be written:\n```rust\nfn foo(fail: bool) -> Result<i32, String> {\n    if fail {\n      return Err(\"failed\".into());\n    }\n    Ok(0)\n}\n```"
    }
  },
  {
    "id": "box_vec",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for use of `Box<Vec<_>>` anywhere in the code.",
      "Why is this bad": "`Vec` already keeps its contents in a separate area on\nthe heap. So if you `Box` it, you just add another level of indirection\nwithout any benefit whatsoever.",
      "Known problems": "None.",
      "Example": "```rust,ignore\nstruct X {\n    values: Box<Vec<Foo>>,\n}\n```\nBetter:\n```rust,ignore\nstruct X {\n    values: Vec<Foo>,\n}\n```"
    }
  },
  {
    "id": "vec_box",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for use of `Vec<Box<T>>` where T: Sized anywhere in the code.",
      "Why is this bad": "`Vec` already keeps its contents in a separate area on\nthe heap. So if you `Box` its contents, you just add another level of indirection.",
      "Known problems": "Vec<Box<T: Sized>> makes sense if T is a large type (see #3530,\n1st comment).",
      "Example": "```rust\nstruct X {\n    values: Vec<Box<i32>>,\n}\n```\nBetter:\n```rust\nstruct X {\n    values: Vec<i32>,\n}\n```"
    }
  },
  {
    "id": "option_option",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for use of `Option<Option<_>>` in function signatures and type\ndefinitions",
      "Why is this bad": "`Option<_>` represents an optional value. `Option<Option<_>>`\nrepresents an optional optional value which is logically the same thing as an optional\nvalue but has an unneeded extra level of wrapping.",
      "Known problems": "None.",
      "Example": "```rust\nfn x() -> Option<Option<u32>> {\n    None\n}\n```"
    }
  },
  {
    "id": "linkedlist",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usage of any `LinkedList`, suggesting to use a\n`Vec` or a `VecDeque` (formerly called `RingBuf`).",
      "Why is this bad": "Gankro says:\n> The TL;DR of `LinkedList` is that it's built on a massive amount of\npointers and indirection.\n> It wastes memory, it has terrible cache locality, and is all-around slow.\n`RingBuf`, while\n> \"only\" amortized for push/pop, should be faster in the general case for\nalmost every possible\n> workload, and isn't even amortized at all if you can predict the capacity\nyou need.\n>\n> `LinkedList`s are only really good if you're doing a lot of merging or\nsplitting of lists.\n> This is because they can just mangle some pointers instead of actually\ncopying the data. Even\n> if you're doing a lot of insertion in the middle of the list, `RingBuf`\ncan still be better\n> because of how expensive it is to seek to the middle of a `LinkedList`.",
      "Known problems": "False positives \u2013 the instances where using a\n`LinkedList` makes sense are few and far between, but they can still happen.",
      "Example": "```rust\nlet x = LinkedList::new();\n```"
    }
  },
  {
    "id": "borrowed_box",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for use of `&Box<T>` anywhere in the code.",
      "Why is this bad": "Any `&Box<T>` can also be a `&T`, which is more\ngeneral.",
      "Known problems": "None.",
      "Example": "```rust,ignore\nfn foo(bar: &Box<T>) { ... }\n```\nBetter:\n```rust,ignore\nfn foo(bar: &T) { ... }\n```"
    }
  },
  {
    "id": "let_unit_value",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for binding a unit value.",
      "Why is this bad": "A unit value cannot usefully be used anywhere. So\nbinding one is kind of pointless.",
      "Known problems": "None.",
      "Example": "```rust\nlet x = {\n    1;\n};\n```"
    }
  },
  {
    "id": "unit_cmp",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for comparisons to unit.",
      "Why is this bad": "Unit is always equal to itself, and thus is just a\nclumsily written constant. Mostly this happens when someone accidentally\nadds semicolons at the end of the operands.",
      "Known problems": "None.",
      "Example": "```rust\n# fn foo() {};\n# fn bar() {};\n# fn baz() {};\nif {\n    foo();\n} == {\n    bar();\n} {\n    baz();\n}\n```\nis equal to\n```rust\n# fn foo() {};\n# fn bar() {};\n# fn baz() {};\n{\n    foo();\n    bar();\n    baz();\n}\n```"
    }
  },
  {
    "id": "unit_arg",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for passing a unit value as an argument to a function without using a\nunit literal (`()`).",
      "Why is this bad": "This is likely the result of an accidental semicolon.",
      "Known problems": "None.",
      "Example": "```rust\nfoo({\n    let a = bar();\n    baz(a);\n})\n```"
    }
  },
  {
    "id": "cast_precision_loss",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for casts from any numerical to a float type where\nthe receiving type cannot store all values from the original type without\nrounding errors. This possible rounding is to be expected, so this lint is\n`Allow` by default.\nBasically, this warns on casting any integer with 32 or more bits to `f32`\nor any 64-bit integer to `f64`.",
      "Why is this bad": "It's not bad at all. But in some applications it can be\nhelpful to know where precision loss can take place. This lint can help find\nthose places in the code.",
      "Known problems": "None.",
      "Example": "```rust\nlet x = u64::MAX;\nx as f64\n```"
    }
  },
  {
    "id": "cast_sign_loss",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for casts from a signed to an unsigned numerical\ntype. In this case, negative values wrap around to large positive values,\nwhich can be quite surprising in practice. However, as the cast works as\ndefined, this lint is `Allow` by default.",
      "Why is this bad": "Possibly surprising results. You can activate this lint\nas a one-time check to see where numerical wrapping can arise.",
      "Known problems": "None.",
      "Example": "```rust\nlet y: i8 = -1;\ny as u128 // will return 18446744073709551615\n```"
    }
  },
  {
    "id": "cast_possible_truncation",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for on casts between numerical types that may\ntruncate large values. This is expected behavior, so the cast is `Allow` by\ndefault.",
      "Why is this bad": "In some problem domains, it is good practice to avoid\ntruncation. This lint can be activated to help assess where additional\nchecks could be beneficial.",
      "Known problems": "None.",
      "Example": "```rust\nfn as_u8(x: u64) -> u8 {\n    x as u8\n}\n```"
    }
  },
  {
    "id": "cast_possible_wrap",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for casts from an unsigned type to a signed type of\nthe same size. Performing such a cast is a 'no-op' for the compiler,\ni.e., nothing is changed at the bit level, and the binary representation of\nthe value is reinterpreted. This can cause wrapping if the value is too big\nfor the target signed type. However, the cast works as defined, so this lint\nis `Allow` by default.",
      "Why is this bad": "While such a cast is not bad in itself, the results can\nbe surprising when this is not the intended behavior, as demonstrated by the\nexample below.",
      "Known problems": "None.",
      "Example": "```rust\nu32::MAX as i32 // will yield a value of `-1`\n```"
    }
  },
  {
    "id": "cast_lossless",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for on casts between numerical types that may\nbe replaced by safe conversion functions.",
      "Why is this bad": "Rust's `as` keyword will perform many kinds of\nconversions, including silently lossy conversions. Conversion functions such\nas `i32::from` will only perform lossless conversions. Using the conversion\nfunctions prevents conversions from turning into silent lossy conversions if\nthe types of the input expressions ever change, and make it easier for\npeople reading the code to know that the conversion is lossless.",
      "Known problems": "None.",
      "Example": "```rust\nfn as_u64(x: u8) -> u64 {\n    x as u64\n}\n```\nUsing `::from` would look like this:\n```rust\nfn as_u64(x: u8) -> u64 {\n    u64::from(x)\n}\n```"
    }
  },
  {
    "id": "unnecessary_cast",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for casts to the same type.",
      "Why is this bad": "It's just unnecessary.",
      "Known problems": "None.",
      "Example": "```rust\nlet _ = 2i32 as i32\n```"
    }
  },
  {
    "id": "cast_ptr_alignment",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for casts from a less-strictly-aligned pointer to a\nmore-strictly-aligned pointer",
      "Why is this bad": "Dereferencing the resulting pointer may be undefined\nbehavior.",
      "Known problems": "Using `std::ptr::read_unaligned` and `std::ptr::write_unaligned` or similar\non the resulting pointer is fine.",
      "Example": "```rust\nlet _ = (&1u8 as *const u8) as *const u16;\nlet _ = (&mut 1u8 as *mut u8) as *mut u16;\n```"
    }
  },
  {
    "id": "fn_to_numeric_cast",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for casts of function pointers to something other than usize",
      "Why is this bad": "Casting a function pointer to anything other than usize/isize is not portable across\narchitectures, because you end up losing bits if the target type is too small or end up with a\nbunch of extra bits that waste space and add more instructions to the final binary than\nstrictly necessary for the problem\nCasting to isize also doesn't make sense since there are no signed addresses.",
      "Example": "```rust\n// Bad\nfn fun() -> i32 { 1 }\nlet a = fun as i64;\n// Good\nfn fun2() -> i32 { 1 }\nlet a = fun2 as usize;\n```"
    }
  },
  {
    "id": "fn_to_numeric_cast_with_truncation",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for casts of a function pointer to a numeric type not wide enough to\nstore address.",
      "Why is this bad": "Such a cast discards some bits of the function's address. If this is intended, it would be more\nclearly expressed by casting to usize first, then casting the usize to the intended type (with\na comment) to perform the truncation.",
      "Example": "```rust\n// Bad\nfn fn1() -> i16 {\n    1\n};\nlet _ = fn1 as i32;\n// Better: Cast to usize first, then comment with the reason for the truncation\nfn fn2() -> i16 {\n    1\n};\nlet fn_ptr = fn2 as usize;\nlet fn_ptr_truncated = fn_ptr as i32;\n```"
    }
  },
  {
    "id": "type_complexity",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for types used in structs, parameters and `let`\ndeclarations above a certain complexity threshold.",
      "Why is this bad": "Too complex types make the code less readable. Consider\nusing a `type` definition to simplify them.",
      "Known problems": "None.",
      "Example": "```rust\nstruct Foo {\n    inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>,\n}\n```",
      "Configuration": "This lint has the following configuration variables:\n\n* `type-complexity-threshold: u64`: The maximum complexity a type can have (defaults to `250 `)."
    }
  },
  {
    "id": "char_lit_as_u8",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for expressions where a character literal is cast\nto `u8` and suggests using a byte literal instead.",
      "Why is this bad": "In general, casting values to smaller types is\nerror-prone and should be avoided where possible. In the particular case of\nconverting a character literal to u8, it is easy to avoid by just using a\nbyte literal instead. As an added bonus, `b'a'` is even slightly shorter\nthan `'a' as u8`.",
      "Known problems": "None.",
      "Example": "```rust\n'x' as u8\n```\nA better version, using the byte literal:\n```rust\nb'x'\n```"
    }
  },
  {
    "id": "absurd_extreme_comparisons",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for comparisons where one side of the relation is\neither the minimum or maximum value for its type and warns if it involves a\ncase that is always true or always false. Only integer and boolean types are\nchecked.",
      "Why is this bad": "An expression like `min <= x` may misleadingly imply\nthat it is possible for `x` to be less than the minimum. Expressions like\n`max < x` are probably mistakes.",
      "Known problems": "For `usize` the size of the current compile target will\nbe assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\na comparison to detect target pointer width will trigger this lint. One can\nuse `mem::sizeof` and compare its value or conditional compilation\nattributes\nlike `#[cfg(target_pointer_width = \"64\")] ..` instead.",
      "Example": "```rust\nlet vec: Vec<isize> = vec![];\nif vec.len() <= 0 {}\nif 100 > std::i32::MAX {}\n```"
    }
  },
  {
    "id": "invalid_upcast_comparisons",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for comparisons where the relation is always either\ntrue or false, but where one side has been upcast so that the comparison is\nnecessary. Only integer types are checked.",
      "Why is this bad": "An expression like `let x : u8 = ...; (x as u32) > 300`\nwill mistakenly imply that it is possible for `x` to be outside the range of\n`u8`.",
      "Known problems": "https://github.com/rust-lang/rust-clippy/issues/886",
      "Example": "```rust\nlet x : u8 = ...; (x as u32) > 300\n```"
    }
  },
  {
    "id": "implicit_hasher",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for public `impl` or `fn` missing generalization\nover different hashers and implicitly defaulting to the default hashing\nalgorithm (SipHash).",
      "Why is this bad": "`HashMap` or `HashSet` with custom hashers cannot be\nused with them.",
      "Known problems": "Suggestions for replacing constructors can contain\nfalse-positives. Also applying suggestions can require modification of other\npieces of code, possibly including external crates.",
      "Example": "```rust\n# use std::collections::HashMap;\n# use std::hash::Hash;\n# trait Serialize {};\nimpl<K: Hash + Eq, V> Serialize for HashMap<K, V> { }\npub fn foo(map: &mut HashMap<i32, i32>) { }\n```"
    }
  },
  {
    "id": "cast_ref_to_mut",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for casts of `&T` to `&mut T` anywhere in the code.",
      "Why is this bad": "It\u2019s basically guaranteed to be undefined behaviour.\n`UnsafeCell` is the only way to obtain aliasable data that is considered\nmutable.",
      "Known problems": "None.",
      "Example": "```rust,ignore\nfn x(r: &i32) {\n    unsafe {\n        *(r as *const _ as *mut _) += 1;\n    }\n}\n```\nInstead consider using interior mutability types.\n```rust\nuse std::cell::UnsafeCell;\nfn x(r: &UnsafeCell<i32>) {\n    unsafe {\n        *r.get() += 1;\n    }\n}\n```"
    }
  },
  {
    "id": "zero_width_space",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for the Unicode zero-width space in the code.",
      "Why is this bad": "Having an invisible character in the code makes for all\nsorts of April fools, but otherwise is very much frowned upon.",
      "Known problems": "None.",
      "Example": "You don't see it, but there may be a zero-width space\nsomewhere in this text."
    }
  },
  {
    "id": "non_ascii_literal",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for non-ASCII characters in string literals.",
      "Why is this bad": "Yeah, we know, the 90's called and wanted their charset\nback. Even so, there still are editors and other programs out there that\ndon't work well with Unicode. So if the code is meant to be used\ninternationally, on multiple operating systems, or has other portability\nrequirements, activating this lint could be useful.",
      "Known problems": "None.",
      "Example": "```rust\nlet x = String::from(\"\u20ac\");\n```\nCould be written as:\n```rust\nlet x = String::from(\"\\u{20ac}\");\n```"
    }
  },
  {
    "id": "unicode_not_nfc",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for string literals that contain Unicode in a form\nthat is not equal to its\n[NFC-recomposition](http://www.unicode.org/reports/tr15/#Norm_Forms).",
      "Why is this bad": "If such a string is compared to another, the results\nmay be surprising.",
      "Known problems": "None.",
      "Example": "You may not see it, but \u201ca\u0300\u201d and \u201c\u00e0\u201d aren't the same string. The\nformer when escaped is actually `\"a\\u{300}\"` while the latter is `\"\\u{e0}\"`."
    }
  },
  {
    "id": "unsafe_removed_from_name",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for imports that remove \"unsafe\" from an item's\nname.",
      "Why is this bad": "Renaming makes it less clear which traits and\nstructures are unsafe.",
      "Known problems": "None.",
      "Example": "```rust,ignore\nuse std::cell::{UnsafeCell as TotallySafeCell};\nextern crate crossbeam;\nuse crossbeam::{spawn_unsafe as spawn};\n```"
    }
  },
  {
    "id": "unused_io_amount",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for unused written/read amount.",
      "Why is this bad": "`io::Write::write` and `io::Read::read` are not\nguaranteed to\nprocess the entire buffer. They return how many bytes were processed, which\nmight be smaller\nthan a given buffer's length. If you don't need to deal with\npartial-write/read, use\n`write_all`/`read_exact` instead.",
      "Known problems": "Detects only common patterns.",
      "Example": "```rust,ignore\nuse std::io;\nfn foo<W: io::Write>(w: &mut W) -> io::Result<()> {\n    // must be `w.write_all(b\"foo\")?;`\n    w.write(b\"foo\")?;\n    Ok(())\n}\n```"
    }
  },
  {
    "id": "unused_label",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for unused labels.",
      "Why is this bad": "Maybe the label should be used in which case there is\nan error in the code or it should be removed.",
      "Known problems": "Hopefully none.",
      "Example": "```rust,ignore\nfn unused_label() {\n    'label: for i in 1..2 {\n        if i > 4 { continue }\n    }\n```"
    }
  },
  {
    "id": "unnecessary_unwrap",
    "group": "nursery",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for calls of `unwrap[_err]()` that cannot fail.",
      "Why is this bad": "Using `if let` or `match` is more idiomatic.",
      "Known problems": "Limitations of the borrow checker might make unwrap() necessary sometimes?",
      "Example": "```rust\nif option.is_some() {\n    do_something_with(option.unwrap())\n}\n```\nCould be written:\n```rust\nif let Some(value) = option {\n    do_something_with(value)\n}\n```"
    }
  },
  {
    "id": "panicking_unwrap",
    "group": "nursery",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for calls of `unwrap[_err]()` that will always fail.",
      "Why is this bad": "If panicking is desired, an explicit `panic!()` should be used.",
      "Known problems": "This lint only checks `if` conditions not assignments.\nSo something like `let x: Option<()> = None; x.unwrap();` will not be recognized.",
      "Example": "```rust\nif option.is_none() {\n    do_something_with(option.unwrap())\n}\n```\nThis code will always panic. The if condition should probably be inverted."
    }
  },
  {
    "id": "use_self",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for unnecessary repetition of structure name when a\nreplacement with `Self` is applicable.",
      "Why is this bad": "Unnecessary repetition. Mixed use of `Self` and struct\nname\nfeels inconsistent.",
      "Known problems": "- False positive when using associated types (#2843)\n- False positives in some situations when using generics (#3410)",
      "Example": "```rust\nstruct Foo {}\nimpl Foo {\n    fn new() -> Foo {\n        Foo {}\n    }\n}\n```\ncould be\n```rust\nstruct Foo {}\nimpl Foo {\n    fn new() -> Self {\n        Self {}\n    }\n}\n```"
    }
  },
  {
    "id": "useless_vec",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of `&vec![..]` when using `&[..]` would\nbe possible.",
      "Why is this bad": "This is less efficient.",
      "Known problems": "None.",
      "Example": "```rust,ignore\nfoo(&vec![1, 2])\n```"
    }
  },
  {
    "id": "wildcard_dependencies",
    "group": "cargo",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for wildcard dependencies in the `Cargo.toml`.",
      "Why is this bad": "[As the edition guide says](https://rust-lang-nursery.github.io/edition-guide/rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html),\nit is highly unlikely that you work with any possible version of your dependency,\nand wildcard dependencies would cause unnecessary breakage in the ecosystem.",
      "Known problems": "None.",
      "Example": "```toml\n[dependencies]\nregex = \"*\"\n```"
    }
  },
  {
    "id": "println_empty_string",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "This lint warns when you use `println!(\"\")` to\nprint a newline.",
      "Why is this bad": "You should use `println!()`, which is simpler.",
      "Known problems": "None.",
      "Example": "```rust\nprintln!(\"\");\n```"
    }
  },
  {
    "id": "print_with_newline",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "This lint warns when you use `print!()` with a format\nstring that\nends in a newline.",
      "Why is this bad": "You should use `println!()` instead, which appends the\nnewline.",
      "Known problems": "None.",
      "Example": "```rust\n# let name = \"World\";\nprint!(\"Hello {}!\\n\", name);\n```\nuse println!() instead\n```rust\n# let name = \"World\";\nprintln!(\"Hello {}!\", name);\n```"
    }
  },
  {
    "id": "print_stdout",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for printing on *stdout*. The purpose of this lint\nis to catch debugging remnants.",
      "Why is this bad": "People often print on *stdout* while debugging an\napplication and might forget to remove those prints afterward.",
      "Known problems": "Only catches `print!` and `println!` calls.",
      "Example": "```rust\nprintln!(\"Hello world!\");\n```"
    }
  },
  {
    "id": "use_debug",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for use of `Debug` formatting. The purpose of this\nlint is to catch debugging remnants.",
      "Why is this bad": "The purpose of the `Debug` trait is to facilitate\ndebugging Rust code. It should not be used in in user-facing output.",
      "Example": "```rust\nprintln!(\"{:?}\", foo);\n```"
    }
  },
  {
    "id": "print_literal",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "This lint warns about the use of literals as `print!`/`println!` args.",
      "Why is this bad": "Using literals as `println!` args is inefficient\n(c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n(i.e., just put the literal in the format string)",
      "Known problems": "Will also warn with macro calls as arguments that expand to literals\n-- e.g., `println!(\"{}\", env!(\"FOO\"))`.",
      "Example": "```rust\nprintln!(\"{}\", \"foo\");\n```\nuse the literal without formatting:\n```rust\nprintln!(\"foo\");\n```"
    }
  },
  {
    "id": "writeln_empty_string",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "This lint warns when you use `writeln!(buf, \"\")` to\nprint a newline.",
      "Why is this bad": "You should use `writeln!(buf)`, which is simpler.",
      "Known problems": "None.",
      "Example": "```rust\n# use std::fmt::Write;\n# let mut buf = String::new();\nwriteln!(buf, \"\");\n```"
    }
  },
  {
    "id": "write_with_newline",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "This lint warns when you use `write!()` with a format\nstring that\nends in a newline.",
      "Why is this bad": "You should use `writeln!()` instead, which appends the\nnewline.",
      "Known problems": "None.",
      "Example": "```rust\n# use std::fmt::Write;\n# let mut buf = String::new();\n# let name = \"World\";\nwrite!(buf, \"Hello {}!\\n\", name);\n```"
    }
  },
  {
    "id": "write_literal",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "This lint warns about the use of literals as `write!`/`writeln!` args.",
      "Why is this bad": "Using literals as `writeln!` args is inefficient\n(c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n(i.e., just put the literal in the format string)",
      "Known problems": "Will also warn with macro calls as arguments that expand to literals\n-- e.g., `writeln!(buf, \"{}\", env!(\"FOO\"))`.",
      "Example": "```rust\n# use std::fmt::Write;\n# let mut buf = String::new();\nwriteln!(buf, \"{}\", \"foo\");\n```"
    }
  },
  {
    "id": "zero_divided_by_zero",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for `0.0 / 0.0`.",
      "Why is this bad": "It's less readable than `std::f32::NAN` or\n`std::f64::NAN`.",
      "Known problems": "None.",
      "Example": "```rust\n0.0f32 / 0.0\n```"
    }
  },
  {
    "id": "option_unwrap_used",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for `.unwrap()` calls on `Option`s.",
      "Why is this bad": "Usually it is better to handle the `None` case, or to\nat least call `.expect(_)` with a more helpful message. Still, for a lot of\nquick-and-dirty code, `unwrap` is a good choice, which is why this lint is\n`Allow` by default.",
      "Known problems": "None.",
      "Example": "```rust\nx.unwrap()\n```"
    }
  },
  {
    "id": "result_unwrap_used",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for `.unwrap()` calls on `Result`s.",
      "Why is this bad": "`result.unwrap()` will let the thread panic on `Err`\nvalues. Normally, you want to implement more sophisticated error handling,\nand propagate errors upwards with `try!`.\nEven if you want to panic on errors, not all `Error`s implement good\nmessages on display. Therefore, it may be beneficial to look at the places\nwhere they may get displayed. Activate this lint to do just that.",
      "Known problems": "None.",
      "Example": "```rust\nx.unwrap()\n```"
    }
  },
  {
    "id": "should_implement_trait",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for methods that should live in a trait\nimplementation of a `std` trait (see [llogiq's blog\npost](http://llogiq.github.io/2015/07/30/traits.html) for further\ninformation) instead of an inherent implementation.",
      "Why is this bad": "Implementing the traits improve ergonomics for users of\nthe code, often with very little cost. Also people seeing a `mul(...)`\nmethod\nmay expect `*` to work equally, so you should have good reason to disappoint\nthem.",
      "Known problems": "None.",
      "Example": "```ignore\nstruct X;\nimpl X {\n    fn add(&self, other: &X) -> X {\n        ..\n    }\n}\n```"
    }
  },
  {
    "id": "wrong_self_convention",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for methods with certain name prefixes and which\ndoesn't match how self is taken. The actual rules are:\n|Prefix |`self` taken          |\n|-------|----------------------|\n|`as_`  |`&self` or `&mut self`|\n|`from_`| none                 |\n|`into_`|`self`                |\n|`is_`  |`&self` or none       |\n|`to_`  |`&self`               |",
      "Why is this bad": "Consistency breeds readability. If you follow the\nconventions, your users won't be surprised that they, e.g., need to supply a\nmutable reference to a `as_..` function.",
      "Known problems": "None.",
      "Example": "```ignore\nimpl X {\n    fn as_str(self) -> &str {\n        ..\n    }\n}\n```"
    }
  },
  {
    "id": "wrong_pub_self_convention",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "This is the same as\n[`wrong_self_convention`](#wrong_self_convention), but for public items.",
      "Why is this bad": "See [`wrong_self_convention`](#wrong_self_convention).",
      "Known problems": "Actually *renaming* the function may break clients if\nthe function is part of the public interface. In that case, be mindful of\nthe stability guarantees you've given your users.",
      "Example": "```rust\nimpl X {\n    pub fn as_str(self) -> &str {\n        ..\n    }\n}\n```"
    }
  },
  {
    "id": "ok_expect",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of `ok().expect(..)`.",
      "Why is this bad": "Because you usually call `expect()` on the `Result`\ndirectly to get a better error message.",
      "Known problems": "The error type needs to implement `Debug`",
      "Example": "```ignore\nx.ok().expect(\"why did I do this again?\")\n```"
    }
  },
  {
    "id": "option_map_unwrap_or",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usage of `_.map(_).unwrap_or(_)`.",
      "Why is this bad": "Readability, this can be written more concisely as\n`_.map_or(_, _)`.",
      "Known problems": "The order of the arguments is not in execution order",
      "Example": "```rust\nx.map(|a| a + 1).unwrap_or(0)\n```"
    }
  },
  {
    "id": "option_map_unwrap_or_else",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usage of `_.map(_).unwrap_or_else(_)`.",
      "Why is this bad": "Readability, this can be written more concisely as\n`_.map_or_else(_, _)`.",
      "Known problems": "The order of the arguments is not in execution order.",
      "Example": "```rust\nx.map(|a| a + 1).unwrap_or_else(some_function)\n```"
    }
  },
  {
    "id": "result_map_unwrap_or_else",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usage of `result.map(_).unwrap_or_else(_)`.",
      "Why is this bad": "Readability, this can be written more concisely as\n`result.ok().map_or_else(_, _)`.",
      "Known problems": "None.",
      "Example": "```rust\nx.map(|a| a + 1).unwrap_or_else(some_function)\n```"
    }
  },
  {
    "id": "option_map_or_none",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of `_.map_or(None, _)`.",
      "Why is this bad": "Readability, this can be written more concisely as\n`_.and_then(_)`.",
      "Known problems": "The order of the arguments is not in execution order.",
      "Example": "```ignore\nopt.map_or(None, |a| a + 1)\n```"
    }
  },
  {
    "id": "filter_next",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of `_.filter(_).next()`.",
      "Why is this bad": "Readability, this can be written more concisely as\n`_.find(_)`.",
      "Known problems": "None.",
      "Example": "```rust\niter.filter(|x| x == 0).next()\n```"
    }
  },
  {
    "id": "map_flatten",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usage of `_.map(_).flatten(_)`,",
      "Why is this bad": "Readability, this can be written more concisely as a\nsingle method call.",
      "Known problems": "",
      "Example": "```rust\niter.map(|x| x.iter()).flatten()\n```"
    }
  },
  {
    "id": "filter_map",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usage of `_.filter(_).map(_)`,\n`_.filter(_).flat_map(_)`, `_.filter_map(_).flat_map(_)` and similar.",
      "Why is this bad": "Readability, this can be written more concisely as a\nsingle method call.",
      "Known problems": "Often requires a condition + Option/Iterator creation\ninside the closure.",
      "Example": "```rust\niter.filter(|x| x == 0).map(|x| x * 2)\n```"
    }
  },
  {
    "id": "filter_map_next",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usage of `_.filter_map(_).next()`.",
      "Why is this bad": "Readability, this can be written more concisely as a\nsingle method call.",
      "Known problems": "None",
      "Example": "```rust\n (0..3).filter_map(|x| if x == 2 { Some(x) } else { None }).next();\n```\nCan be written as\n```rust\n (0..3).find_map(|x| if x == 2 { Some(x) } else { None });\n```"
    }
  },
  {
    "id": "find_map",
    "group": "pedantic",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usage of `_.find(_).map(_)`.",
      "Why is this bad": "Readability, this can be written more concisely as a\nsingle method call.",
      "Known problems": "Often requires a condition + Option/Iterator creation\ninside the closure.",
      "Example": "```rust\n (0..3).find(|x| x == 2).map(|x| x * 2);\n```\nCan be written as\n```rust\n (0..3).find_map(|x| if x == 2 { Some(x * 2) } else { None });\n```"
    }
  },
  {
    "id": "search_is_some",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for an iterator search (such as `find()`,\n`position()`, or `rposition()`) followed by a call to `is_some()`.",
      "Why is this bad": "Readability, this can be written more concisely as\n`_.any(_)`.",
      "Known problems": "None.",
      "Example": "```rust\niter.find(|x| x == 0).is_some()\n```"
    }
  },
  {
    "id": "chars_next_cmp",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of `.chars().next()` on a `str` to check\nif it starts with a given char.",
      "Why is this bad": "Readability, this can be written more concisely as\n`_.starts_with(_)`.",
      "Known problems": "None.",
      "Example": "```rust\nname.chars().next() == Some('_')\n```"
    }
  },
  {
    "id": "or_fun_call",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`,\netc., and suggests to use `or_else`, `unwrap_or_else`, etc., or\n`unwrap_or_default` instead.",
      "Why is this bad": "The function will always be called and potentially\nallocate an object acting as the default.",
      "Known problems": "If the function has side-effects, not calling it will\nchange the semantic of the program, but you shouldn't rely on that anyway.",
      "Example": "```rust\nfoo.unwrap_or(String::new())\n```\nthis can instead be written:\n```rust\nfoo.unwrap_or_else(String::new)\n```\nor\n```rust\nfoo.unwrap_or_default()\n```"
    }
  },
  {
    "id": "expect_fun_call",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for calls to `.expect(&format!(...))`, `.expect(foo(..))`,\netc., and suggests to use `unwrap_or_else` instead",
      "Why is this bad": "The function will always be called.",
      "Known problems": "If the function has side-effects, not calling it will\nchange the semantics of the program, but you shouldn't rely on that anyway.",
      "Example": "```rust\nfoo.expect(&format!(\"Err {}: {}\", err_code, err_msg))\n```\nor\n```rust\nfoo.expect(format!(\"Err {}: {}\", err_code, err_msg).as_str())\n```\nthis can instead be written:\n```rust\nfoo.unwrap_or_else(|_| panic!(\"Err {}: {}\", err_code, err_msg))\n```"
    }
  },
  {
    "id": "clone_on_copy",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of `.clone()` on a `Copy` type.",
      "Why is this bad": "The only reason `Copy` types implement `Clone` is for\ngenerics, not for using the `clone` method on a concrete type.",
      "Known problems": "None.",
      "Example": "```rust\n42u64.clone()\n```"
    }
  },
  {
    "id": "clone_on_ref_ptr",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for usage of `.clone()` on a ref-counted pointer,\n(`Rc`, `Arc`, `rc::Weak`, or `sync::Weak`), and suggests calling Clone via unified\nfunction syntax instead (e.g., `Rc::clone(foo)`).",
      "Why is this bad": "Calling '.clone()' on an Rc, Arc, or Weak\ncan obscure the fact that only the pointer is being cloned, not the underlying\ndata.",
      "Example": "```rust\nx.clone()\n```"
    }
  },
  {
    "id": "clone_double_ref",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for usage of `.clone()` on an `&&T`.",
      "Why is this bad": "Cloning an `&&T` copies the inner `&T`, instead of\ncloning the underlying `T`.",
      "Known problems": "None.",
      "Example": "```rust\nfn main() {\n    let x = vec![1];\n    let y = &&x;\n    let z = y.clone();\n    println!(\"{:p} {:p}\", *y, z); // prints out the same pointer\n}\n```"
    }
  },
  {
    "id": "new_ret_no_self",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for `new` not returning `Self`.",
      "Why is this bad": "As a convention, `new` methods are used to make a new\ninstance of a type.",
      "Known problems": "None.",
      "Example": "```ignore\nimpl Foo {\n    fn new(..) -> NotAFoo {\n    }\n}\n```"
    }
  },
  {
    "id": "single_char_pattern",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for string methods that receive a single-character\n`str` as an argument, e.g., `_.split(\"x\")`.",
      "Why is this bad": "Performing these methods using a `char` is faster than\nusing a `str`.",
      "Known problems": "Does not catch multi-byte unicode characters.",
      "Example": "`_.split(\"x\")` could be `_.split('x')`"
    }
  },
  {
    "id": "temporary_cstring_as_ptr",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for getting the inner pointer of a temporary\n`CString`.",
      "Why is this bad": "The inner pointer of a `CString` is only valid as long\nas the `CString` is alive.",
      "Known problems": "None.",
      "Example": "```rust,ignore\nlet c_str = CString::new(\"foo\").unwrap().as_ptr();\nunsafe {\n    call_some_ffi_func(c_str);\n}\n```\nHere `c_str` point to a freed address. The correct use would be:\n```rust,ignore\nlet c_str = CString::new(\"foo\").unwrap();\nunsafe {\n    call_some_ffi_func(c_str.as_ptr());\n}\n```"
    }
  },
  {
    "id": "iter_nth",
    "group": "perf",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for use of `.iter().nth()` (and the related\n`.iter_mut().nth()`) on standard library types with O(1) element access.",
      "Why is this bad": "`.get()` and `.get_mut()` are more efficient and more\nreadable.",
      "Known problems": "None.",
      "Example": "```rust\nlet some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.iter().nth(3);\nlet bad_slice = &some_vec[..].iter().nth(3);\n```\nThe correct use would be:\n```rust\nlet some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.get(3);\nlet bad_slice = &some_vec[..].get(3);\n```"
    }
  },
  {
    "id": "iter_skip_next",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for use of `.skip(x).next()` on iterators.",
      "Why is this bad": "`.nth(x)` is cleaner",
      "Known problems": "None.",
      "Example": "```rust\nlet some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.iter().skip(3).next();\nlet bad_slice = &some_vec[..].iter().skip(3).next();\n```\nThe correct use would be:\n```rust\nlet some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.iter().nth(3);\nlet bad_slice = &some_vec[..].iter().nth(3);\n```"
    }
  },
  {
    "id": "get_unwrap",
    "group": "restriction",
    "level": "Allow",
    "docs": {
      "What it does": "Checks for use of `.get().unwrap()` (or\n`.get_mut().unwrap`) on a standard library type which implements `Index`",
      "Why is this bad": "Using the Index trait (`[]`) is more clear and more\nconcise.",
      "Known problems": "Not a replacement for error handling: Using either\n`.unwrap()` or the Index trait (`[]`) carries the risk of causing a `panic`\nif the value being accessed is `None`. If the use of `.get().unwrap()` is a\ntemporary placeholder for dealing with the `Option` type, then this does\nnot mitigate the need for error handling. If there is a chance that `.get()`\nwill be `None` in your program, then it is advisable that the `None` case\nis handled in a future refactor instead of using `.unwrap()` or the Index\ntrait.",
      "Example": "```rust\nlet mut some_vec = vec![0, 1, 2, 3];\nlet last = some_vec.get(3).unwrap();\n*some_vec.get_mut(0).unwrap() = 1;\n```\nThe correct use would be:\n```rust\nlet mut some_vec = vec![0, 1, 2, 3];\nlet last = some_vec[3];\nsome_vec[0] = 1;\n```"
    }
  },
  {
    "id": "string_extend_chars",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for the use of `.extend(s.chars())` where s is a\n`&str` or `String`.",
      "Why is this bad": "`.push_str(s)` is clearer",
      "Known problems": "None.",
      "Example": "```rust\nlet abc = \"abc\";\nlet def = String::from(\"def\");\nlet mut s = String::new();\ns.extend(abc.chars());\ns.extend(def.chars());\n```\nThe correct use would be:\n```rust\nlet abc = \"abc\";\nlet def = String::from(\"def\");\nlet mut s = String::new();\ns.push_str(abc);\ns.push_str(&def);\n```"
    }
  },
  {
    "id": "iter_cloned_collect",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for the use of `.cloned().collect()` on slice to\ncreate a `Vec`.",
      "Why is this bad": "`.to_vec()` is clearer",
      "Known problems": "None.",
      "Example": "```rust\nlet s = [1, 2, 3, 4, 5];\nlet s2: Vec<isize> = s[..].iter().cloned().collect();\n```\nThe better use would be:\n```rust\nlet s = [1, 2, 3, 4, 5];\nlet s2: Vec<isize> = s.to_vec();\n```"
    }
  },
  {
    "id": "chars_last_cmp",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of `.chars().last()` or\n`.chars().next_back()` on a `str` to check if it ends with a given char.",
      "Why is this bad": "Readability, this can be written more concisely as\n`_.ends_with(_)`.",
      "Known problems": "None.",
      "Example": "```ignore\nname.chars().last() == Some('_') || name.chars().next_back() == Some('-')\n```"
    }
  },
  {
    "id": "useless_asref",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for usage of `.as_ref()` or `.as_mut()` where the\ntypes before and after the call are the same.",
      "Why is this bad": "The call is unnecessary.",
      "Known problems": "None.",
      "Example": "```rust\nlet x: &[i32] = &[1, 2, 3, 4, 5];\ndo_stuff(x.as_ref());\n```\nThe correct use would be:\n```rust\nlet x: &[i32] = &[1, 2, 3, 4, 5];\ndo_stuff(x);\n```"
    }
  },
  {
    "id": "unnecessary_fold",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for using `fold` when a more succinct alternative exists.\nSpecifically, this checks for `fold`s which could be replaced by `any`, `all`,\n`sum` or `product`.",
      "Why is this bad": "Readability.",
      "Known problems": "False positive in pattern guards. Will be resolved once\nnon-lexical lifetimes are stable.",
      "Example": "```rust\nlet _ = (0..3).fold(false, |acc, x| acc || x > 2);\n```\nThis could be written as:\n```rust\nlet _ = (0..3).any(|x| x > 2);\n```"
    }
  },
  {
    "id": "unnecessary_filter_map",
    "group": "complexity",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for `filter_map` calls which could be replaced by `filter` or `map`.\nMore specifically it checks if the closure provided is only performing one of the\nfilter or map operations and suggests the appropriate option.",
      "Why is this bad": "Complexity. The intent is also clearer if only a single\noperation is being performed.",
      "Known problems": "None",
      "Example": "```rust\nlet _ = (0..3).filter_map(|x| if x > 2 { Some(x) } else { None });\n```\nAs there is no transformation of the argument this could be written as:\n```rust\nlet _ = (0..3).filter(|&x| x > 2);\n```\n```rust\nlet _ = (0..4).filter_map(i32::checked_abs);\n```\nAs there is no conditional check on the argument this could be written as:\n```rust\nlet _ = (0..4).map(i32::checked_abs);\n```"
    }
  },
  {
    "id": "into_iter_on_array",
    "group": "correctness",
    "level": "Deny",
    "docs": {
      "What it does": "Checks for `into_iter` calls on types which should be replaced by `iter` or\n`iter_mut`.",
      "Why is this bad": "Arrays and `PathBuf` do not yet have an `into_iter` method which move out\ntheir content into an iterator. Auto-referencing resolves the `into_iter` call to its reference\ninstead, like `<&[T; N] as IntoIterator>::into_iter`, which just iterates over item references\nlike calling `iter` would. Furthermore, when the standard library actually\n[implements the `into_iter` method](https://github.com/rust-lang/rust/issues/25725) which moves\nthe content out of the array, the original use of `into_iter` got inferred with the wrong type\nand the code will be broken.",
      "Known problems": "None",
      "Example": "```rust\nlet _ = [1, 2, 3].into_iter().map(|x| *x).collect::<Vec<u32>>();\n```"
    }
  },
  {
    "id": "into_iter_on_ref",
    "group": "style",
    "level": "Warn",
    "docs": {
      "What it does": "Checks for `into_iter` calls on references which should be replaced by `iter`\nor `iter_mut`.",
      "Why is this bad": "Readability. Calling `into_iter` on a reference will not move out its\ncontent into the resulting iterator, which is confusing. It is better just call `iter` or\n`iter_mut` directly.",
      "Known problems": "None",
      "Example": "```rust\nlet _ = (&vec![3, 4, 5]).into_iter();\n```"
    }
  }
]