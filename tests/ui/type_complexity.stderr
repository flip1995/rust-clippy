error: very complex type used. Consider factoring parts into `type` definitions
  --> tests/ui/type_complexity.rs:7:12
   |
LL | const CST: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0))));
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `-D clippy::type-complexity` implied by `-D warnings`
   = help: to override `-D warnings` add `#[allow(clippy::type_complexity)]`

error: very complex type used. Consider factoring parts into `type` definitions
  --> tests/ui/type_complexity.rs:11:12
   |
LL | static ST: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0))));
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> tests/ui/type_complexity.rs:16:8
   |
LL |     f: Vec<Vec<Box<(u32, u32, u32, u32)>>>,
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> tests/ui/type_complexity.rs:21:11
   |
LL | struct Ts(Vec<Vec<Box<(u32, u32, u32, u32)>>>);
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> tests/ui/type_complexity.rs:26:11
   |
LL |     Tuple(Vec<Vec<Box<(u32, u32, u32, u32)>>>),
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> tests/ui/type_complexity.rs:29:17
   |
LL |     Struct { f: Vec<Vec<Box<(u32, u32, u32, u32)>>> },
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> tests/ui/type_complexity.rs:35:14
   |
LL |     const A: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0))));
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> tests/ui/type_complexity.rs:38:30
   |
LL |     fn impl_method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>) {}
   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> tests/ui/type_complexity.rs:44:14
   |
LL |     const A: Vec<Vec<Box<(u32, u32, u32, u32)>>>;
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> tests/ui/type_complexity.rs:47:14
   |
LL |     type B = Vec<Vec<Box<(u32, u32, u32, u32)>>>;
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> tests/ui/type_complexity.rs:50:25
   |
LL |     fn method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>);
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> tests/ui/type_complexity.rs:53:29
   |
LL |     fn def_method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>) {}
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> tests/ui/type_complexity.rs:67:15
   |
LL | fn test1() -> Vec<Vec<Box<(u32, u32, u32, u32)>>> {
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> tests/ui/type_complexity.rs:73:14
   |
LL | fn test2(_x: Vec<Vec<Box<(u32, u32, u32, u32)>>>) {}
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: very complex type used. Consider factoring parts into `type` definitions
  --> tests/ui/type_complexity.rs:78:13
   |
LL |     let _y: Vec<Vec<Box<(u32, u32, u32, u32)>>> = vec![];
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: aborting due to 15 previous errors

