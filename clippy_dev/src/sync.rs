use std::fmt::Write;
use std::path::Path;
use std::process;
use std::process::exit;

use chrono::offset::Utc;
use xshell::{cmd, Shell};

use crate::{clippy_project_root, update_lints};

const JOSH_FILTER: &str = ":rev(20b085d500dfba5afe0869707bf357af3afe20be:prefix=src/tools/clippy):/src/tools/clippy";
const JOSH_PORT: &str = "42042";

fn start_josh() -> impl Drop {
    // Create a wrapper that stops it on drop.
    struct Josh(process::Child);
    impl Drop for Josh {
        fn drop(&mut self) {
            #[cfg(unix)]
            {
                // Try to gracefully shut it down.
                process::Command::new("kill")
                    .args(["-s", "INT", &self.0.id().to_string()])
                    .output()
                    .expect("failed to SIGINT josh-proxy");
                // Sadly there is no "wait with timeout"... so we just give it some time to finish.
                std::thread::sleep(std::time::Duration::from_secs(1));
                // Now hopefully it is gone.
                if self.0.try_wait().expect("failed to wait for josh-proxy").is_some() {
                    return;
                }
            }
            // If that didn't work (or we're not on Unix), kill it hard.
            eprintln!("I have to kill josh-proxy the hard way, let's hope this does not break anything.");
            self.0.kill().expect("failed to SIGKILL josh-proxy");
        }
    }

    // Determine cache directory.
    let local_dir = {
        let user_dirs = directories::ProjectDirs::from("org", "rust-lang", "clippy-josh").unwrap();
        user_dirs.cache_dir().to_owned()
    };
    println!("Using local cache directory: {}", local_dir.display());

    // Start josh, silencing its output.
    let mut cmd = process::Command::new("josh-proxy");
    cmd.arg("--local").arg(local_dir);
    cmd.arg("--remote").arg("https://github.com");
    cmd.arg("--port").arg(JOSH_PORT);
    cmd.arg("--no-background");
    cmd.stdout(process::Stdio::null());
    cmd.stderr(process::Stdio::null());
    let josh = cmd
        .spawn()
        .expect("failed to start josh-proxy, make sure it is installed");
    // Give it some time so hopefully the port is open.
    std::thread::sleep(std::time::Duration::from_secs(1));

    Josh(josh)
}

fn rustc_hash() -> String {
    let version = String::from_utf8(
        process::Command::new("rustc")
            .arg("--version")
            .arg("--verbose")
            .output()
            .expect("failed to run rustc")
            .stdout,
    )
    .unwrap();
    version
        .lines()
        .find(|line| line.starts_with("commit-hash:"))
        .expect("failed to parse `rustc -vV`")
        .split_whitespace()
        .nth(1)
        .expect("failed to get commit from `rustc -vV`")
        .to_string()
}

fn assert_clean_repo(sh: &Shell) {
    if !cmd!(sh, "git status --untracked-files=no --porcelain")
        .read()
        .expect("failed to run git status")
        .is_empty()
    {
        eprintln!("working directory must be clean before running `cargo dev sync pull`");
        exit(1);
    }
}

pub fn update_toolchain() {
    let sh = Shell::new().expect("failed to create shell");
    sh.change_dir(clippy_project_root());

    assert_clean_repo(&sh);

    // Update rust-toolchain file
    let date = Utc::now().format("%Y-%m-%d").to_string();
    update_lints::replace_region_in_file(
        update_lints::UpdateMode::Change,
        Path::new("rust-toolchain"),
        "# begin autogenerated version\n",
        "# end autogenerated version",
        |res| {
            writeln!(res, "channel = \"nightly-{date}\"").unwrap();
        },
    );

    let message = format!("Bump nightly version -> {date}");
    cmd!(sh, "git commit rust-toolchain --no-verify -m {message}")
        .run()
        .expect("FAILED to commit rust-toolchain file, something went wrong");
}

pub fn rustc_pull(hash: Option<String>) {
    const MERGE_COMMIT_MESSAGE: &str = "Merge from rustc";

    let sh = Shell::new().expect("failed to create shell");
    sh.change_dir(clippy_project_root());

    assert_clean_repo(&sh);

    let date = Utc::now().format("%Y-%m-%d").to_string();
    if hash.is_none()
        && !std::fs::read_to_string("rust-toolchain")
            .expect("failed to read rust-toolchain file")
            .contains(&date)
    {
        eprintln!("Toolchain must be up to date before running `cargo dev sync pull`");
        exit(1);
    }

    let commit = hash.unwrap_or_else(rustc_hash);

    // Make sure josh is running in this scope
    {
        let _josh = start_josh();

        // Fetch given rustc commit.
        cmd!(
            sh,
            "git fetch http://localhost:{JOSH_PORT}/rust-lang/rust.git@{commit}{JOSH_FILTER}.git"
        )
        .run()
        .expect(
            "FAILED to fetch new commits, something went wrong (committing the rust-toolchain file has been undone)",
        );
    }

    // This should not add any new root commits. So count those before and after merging.
    let num_roots = || -> u32 {
        cmd!(sh, "git rev-list HEAD --max-parents=0 --count")
            .read()
            .expect("failed to determine the number of root commits")
            .parse::<u32>()
            .unwrap()
    };
    let num_roots_before = num_roots();

    // Merge the fetched commit.
    cmd!(sh, "git merge FETCH_HEAD --no-verify --no-ff -m {MERGE_COMMIT_MESSAGE}")
        .run()
        .expect("FAILED to merge new commits, something went wrong");

    // Check that the number of roots did not increase.
    if num_roots() != num_roots_before {
        eprintln!("Josh created a new root commit. This is probably not the history you want.");
        exit(1);
    }
}

pub fn rustc_push(rustc_path: String, github_user: &str) {
    const BRANCH: &str = "clippy-subtree-update";

    let sh = Shell::new().expect("failed to create shell");
    sh.change_dir(clippy_project_root());

    assert_clean_repo(&sh);

    // Prepare the branch. Pushing works much better if we use as base exactly
    // the commit that we pulled from last time, so we use the `rustc --version`
    // to find out which commit that would be.
    let base = rustc_hash();

    println!("Preparing {github_user}/rust (base: {base})...");
    sh.change_dir(rustc_path);
    if cmd!(sh, "git fetch https://github.com/{github_user}/rust {BRANCH}")
        .ignore_stderr()
        .read()
        .is_ok()
    {
        eprintln!(
            "The branch '{BRANCH}' seems to already exist in 'https://github.com/{github_user}/rust'. Please delete it and try again."
        );
        exit(1);
    }
    cmd!(sh, "git fetch https://github.com/rust-lang/rust {base}")
        .run()
        .expect("failed to fetch base commit");
    cmd!(
        sh,
        "git push https://github.com/{github_user}/rust {base}:refs/heads/{BRANCH}"
    )
    .ignore_stdout()
    .ignore_stderr() // silence the "create GitHub PR" message
    .run()
    .expect("failed to push base commit to the new branch");

    // Make sure josh is running in this scope
    {
        let _josh = start_josh();

        // Do the actual push.
        sh.change_dir(clippy_project_root());
        println!("Pushing Clippy changes...");
        cmd!(
            sh,
            "git push http://localhost:{JOSH_PORT}/{github_user}/rust.git{JOSH_FILTER}.git HEAD:{BRANCH}"
        )
        .run()
        .expect("failed to push changes to Josh");

        // Do a round-trip check to make sure the push worked as expected.
        cmd!(
            sh,
            "git fetch http://localhost:{JOSH_PORT}/{github_user}/rust.git{JOSH_FILTER}.git {BRANCH}"
        )
        .ignore_stderr()
        .read()
        .expect("failed to fetch the branch from Josh");
    }

    let head = cmd!(sh, "git rev-parse HEAD")
        .read()
        .expect("failed to get HEAD commit");
    let fetch_head = cmd!(sh, "git rev-parse FETCH_HEAD")
        .read()
        .expect("failed to get FETCH_HEAD");
    if head != fetch_head {
        eprintln!("Josh created a non-roundtrip push! Do NOT merge this into rustc!");
        exit(1);
    }
    println!("Confirmed that the push round-trips back to Clippy properly. Please create a rustc PR:");
    println!(
        // Open PR with `subtree update` title to silence the `no-merges` triagebot check
        // See https://github.com/rust-lang/rust/pull/114157
        "    https://github.com/rust-lang/rust/compare/{github_user}:{BRANCH}?quick_pull=1&title=Clippy+subtree+update&body=r?+@ghost"
    );
}
