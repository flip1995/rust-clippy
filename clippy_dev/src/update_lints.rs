use crate::utils::{File, FileAction, FileUpdater, UpdateMode, UpdateStatus, panic_file, update_text_region_fn};
use core::str;
use itertools::Itertools;
use rustc_lexer::{LiteralKind, TokenKind, tokenize};
use rustc_literal_escaper::{Mode, unescape_unicode};
use std::collections::{HashMap, HashSet};
use std::fmt::Write;
use std::fs::OpenOptions;
use std::ops::Range;
use std::path::Path;
use walkdir::{DirEntry, WalkDir};

const GENERATED_FILE_COMMENT: &str = "// This file was generated by `cargo dev update_lints`.\n\
     // Use that command to update this file and do not edit by hand.\n\
     // Manual edits will be overwritten.\n\n";

const DOCS_LINK: &str = "https://rust-lang.github.io/rust-clippy/master/index.html";

/// Runs the `update_lints` command.
///
/// This updates various generated values from the lint source code.
///
/// `update_mode` indicates if the files should be updated or if updates should be checked for.
///
/// # Panics
///
/// Panics if a file path could not read from or then written to
pub fn update(update_mode: UpdateMode) {
    let lints = find_lint_decls();
    let DeprecatedLints {
        renamed, deprecated, ..
    } = read_deprecated_lints();
    generate_lint_files(update_mode, &lints, &deprecated, &renamed);
}

pub fn generate_lint_files(
    update_mode: UpdateMode,
    lints: &[Lint],
    deprecated: &[DeprecatedLint],
    renamed: &[RenamedLint],
) {
    FileUpdater::default().update_files_checked(
        "cargo dev update_lints",
        update_mode,
        &mut [
            (
                "README.md",
                &mut update_text_region_fn("[There are over ", " lints included in this crate!]", |dst| {
                    write!(dst, "{}", round_to_fifty(lints.len())).unwrap();
                }),
            ),
            (
                "book/src/README.md",
                &mut update_text_region_fn("[There are over ", " lints included in this crate!]", |dst| {
                    write!(dst, "{}", round_to_fifty(lints.len())).unwrap();
                }),
            ),
            (
                "CHANGELOG.md",
                &mut update_text_region_fn(
                    "<!-- begin autogenerated links to lint list -->\n",
                    "<!-- end autogenerated links to lint list -->",
                    |dst| {
                        for lint in lints
                            .iter()
                            .map(|l| &*l.name)
                            .chain(deprecated.iter().filter_map(|l| l.name.strip_prefix("clippy::")))
                            .chain(renamed.iter().filter_map(|l| l.old_name.strip_prefix("clippy::")))
                            .sorted()
                        {
                            writeln!(dst, "[`{lint}`]: {DOCS_LINK}#{lint}").unwrap();
                        }
                    },
                ),
            ),
            (
                "clippy_lints/src/lib.rs",
                &mut update_text_region_fn(
                    "// begin lints modules, do not remove this comment, it’s used in `update_lints`\n",
                    "// end lints modules, do not remove this comment, it’s used in `update_lints`",
                    |dst| {
                        for lint_mod in lints.iter().map(|l| &l.module).sorted().dedup() {
                            writeln!(dst, "mod {lint_mod};").unwrap();
                        }
                    },
                ),
            ),
            ("clippy_lints/src/declared_lints.rs", &mut |_, src, dst| {
                dst.push_str(GENERATED_FILE_COMMENT);
                dst.push_str("pub static LINTS: &[&crate::LintInfo] = &[\n");
                for (module_name, lint_name) in lints.iter().map(|l| (&l.module, l.name.to_uppercase())).sorted() {
                    writeln!(dst, "    crate::{module_name}::{lint_name}_INFO,").unwrap();
                }
                dst.push_str("];\n");
                UpdateStatus::from_changed(src != dst)
            }),
            ("tests/ui/deprecated.rs", &mut |_, src, dst| {
                dst.push_str(GENERATED_FILE_COMMENT);
                for lint in deprecated {
                    writeln!(dst, "#![warn({})] //~ ERROR: lint `{}`", lint.name, lint.name).unwrap();
                }
                dst.push_str("\nfn main() {}\n");
                UpdateStatus::from_changed(src != dst)
            }),
            ("tests/ui/rename.rs", &mut gen_renamed_lints_test_fn(renamed)),
        ],
    );
}

pub fn print_lints() {
    let lints = find_lint_decls();
    let lint_count = lints.len();
    let grouped_by_lint_group = Lint::by_lint_group(lints.into_iter());

    for (lint_group, mut lints) in grouped_by_lint_group {
        println!("\n## {lint_group}");

        lints.sort_by_key(|l| l.name.clone());

        for lint in lints {
            println!("* [{}]({DOCS_LINK}#{}) ({})", lint.name, lint.name, lint.desc);
        }
    }

    println!("there are {lint_count} lints");
}

fn round_to_fifty(count: usize) -> usize {
    count / 50 * 50
}

/// Lint data parsed from the Clippy source code.
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct Lint {
    pub name: String,
    pub group: String,
    pub desc: String,
    pub module: String,
    pub declaration_range: Range<usize>,
}

impl Lint {
    #[must_use]
    fn new(name: &str, group: &str, desc: &str, module: &str, declaration_range: Range<usize>) -> Self {
        Self {
            name: name.to_lowercase(),
            group: group.into(),
            desc: remove_line_splices(desc),
            module: module.into(),
            declaration_range,
        }
    }

    /// Returns the lints in a `HashMap`, grouped by the different lint groups
    #[must_use]
    fn by_lint_group(lints: impl Iterator<Item = Self>) -> HashMap<String, Vec<Self>> {
        lints.map(|lint| (lint.group.to_string(), lint)).into_group_map()
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct DeprecatedLint {
    pub name: String,
    pub reason: String,
}
impl DeprecatedLint {
    fn new(name: &str, reason: &str) -> Self {
        Self {
            name: remove_line_splices(name),
            reason: remove_line_splices(reason),
        }
    }
}

pub struct RenamedLint {
    pub old_name: String,
    pub new_name: String,
}
impl RenamedLint {
    fn new(old_name: &str, new_name: &str) -> Self {
        Self {
            old_name: remove_line_splices(old_name),
            new_name: remove_line_splices(new_name),
        }
    }
}

pub fn gen_renamed_lints_test_fn(lints: &[RenamedLint]) -> impl Fn(&Path, &str, &mut String) -> UpdateStatus {
    move |_, src, dst| {
        let mut seen_lints = HashSet::new();
        dst.push_str(GENERATED_FILE_COMMENT);
        dst.push_str("#![allow(clippy::duplicated_attributes)]\n");
        for lint in lints {
            if seen_lints.insert(&lint.new_name) {
                writeln!(dst, "#![allow({})]", lint.new_name).unwrap();
            }
        }
        seen_lints.clear();
        for lint in lints {
            if seen_lints.insert(&lint.old_name) {
                writeln!(dst, "#![warn({})] //~ ERROR: lint `{}`", lint.old_name, lint.old_name).unwrap();
            }
        }
        dst.push_str("\nfn main() {}\n");
        UpdateStatus::from_changed(src != dst)
    }
}

/// Finds all lint declarations (`declare_clippy_lint!`)
#[must_use]
pub fn find_lint_decls() -> Vec<Lint> {
    let mut lints = Vec::with_capacity(1000);
    let mut contents = String::new();
    for (file, module) in read_src_with_module("clippy_lints/src".as_ref()) {
        parse_clippy_lint_decls(
            File::open_read_to_cleared_string(file.path(), &mut contents),
            &module,
            &mut lints,
        );
    }
    lints.sort_by(|lhs, rhs| lhs.name.cmp(&rhs.name));
    lints
}

/// Reads the source files from the given root directory
fn read_src_with_module(src_root: &Path) -> impl use<'_> + Iterator<Item = (DirEntry, String)> {
    WalkDir::new(src_root).into_iter().filter_map(move |e| {
        let e = match e {
            Ok(e) => e,
            Err(ref e) => panic_file(e, FileAction::Read, src_root),
        };
        let path = e.path().as_os_str().as_encoded_bytes();
        if let Some(path) = path.strip_suffix(b".rs")
            && let Some(path) = path.get("clippy_lints/src/".len()..)
        {
            if path == b"lib" {
                Some((e, String::new()))
            } else {
                let path = if let Some(path) = path.strip_suffix(b"mod")
                    && let Some(path) = path.strip_suffix(b"/").or_else(|| path.strip_suffix(b"\\"))
                {
                    path
                } else {
                    path
                };
                if let Ok(path) = str::from_utf8(path) {
                    let path = path.replace(['/', '\\'], "::");
                    Some((e, path))
                } else {
                    None
                }
            }
        } else {
            None
        }
    })
}

macro_rules! match_tokens {
    ($iter:ident, $($token:ident $({$($fields:tt)*})? $(($capture:ident))?)*) => {
         {
            $(#[allow(clippy::redundant_pattern)] let Some(LintDeclSearchResult {
                    token_kind: TokenKind::$token $({$($fields)*})?,
                    content: $($capture @)? _,
                    ..
            }) = $iter.next() else {
                continue;
            };)*
            #[allow(clippy::unused_unit)]
            { ($($($capture,)?)*) }
        }
    }
}

pub(crate) use match_tokens;

pub(crate) struct LintDeclSearchResult<'a> {
    pub token_kind: TokenKind,
    pub content: &'a str,
    pub range: Range<usize>,
}

/// Parse a source file looking for `declare_clippy_lint` macro invocations.
fn parse_clippy_lint_decls(contents: &str, module: &str, lints: &mut Vec<Lint>) {
    let mut offset = 0usize;
    let mut iter = tokenize(contents).map(|t| {
        let range = offset..offset + t.len as usize;
        offset = range.end;

        LintDeclSearchResult {
            token_kind: t.kind,
            content: &contents[range.clone()],
            range,
        }
    });

    while let Some(LintDeclSearchResult { range, .. }) = iter.find(
        |LintDeclSearchResult {
             token_kind, content, ..
         }| token_kind == &TokenKind::Ident && *content == "declare_clippy_lint",
    ) {
        let start = range.start;
        let mut iter = iter
            .by_ref()
            .filter(|t| !matches!(t.token_kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));
        // matches `!{`
        match_tokens!(iter, Bang OpenBrace);
        match iter.next() {
            // #[clippy::version = "version"] pub
            Some(LintDeclSearchResult {
                token_kind: TokenKind::Pound,
                ..
            }) => {
                match_tokens!(iter, OpenBracket Ident Colon Colon Ident Eq Literal{..} CloseBracket Ident);
            },
            // pub
            Some(LintDeclSearchResult {
                token_kind: TokenKind::Ident,
                ..
            }) => (),
            _ => continue,
        }

        let (name, group, desc) = match_tokens!(
            iter,
            // LINT_NAME
            Ident(name) Comma
            // group,
            Ident(group) Comma
            // "description"
            Literal{..}(desc)
        );

        if let Some(end) = iter.find_map(|t| {
            if let LintDeclSearchResult {
                token_kind: TokenKind::CloseBrace,
                range,
                ..
            } = t
            {
                Some(range.end)
            } else {
                None
            }
        }) {
            lints.push(Lint::new(name, group, desc, module, start..end));
        }
    }
}

pub struct DeprecatedLints {
    pub file: File<'static>,
    pub contents: String,
    pub deprecated: Vec<DeprecatedLint>,
    pub renamed: Vec<RenamedLint>,
    pub deprecated_end: u32,
    pub renamed_end: u32,
}

#[must_use]
#[expect(clippy::cast_possible_truncation)]
pub fn read_deprecated_lints() -> DeprecatedLints {
    let mut res = DeprecatedLints {
        file: File::open(
            "clippy_lints/src/deprecated_lints.rs",
            OpenOptions::new().read(true).write(true),
        ),
        contents: String::new(),
        deprecated: Vec::with_capacity(30),
        renamed: Vec::with_capacity(80),
        deprecated_end: 0,
        renamed_end: 0,
    };

    res.file.read_append_to_string(&mut res.contents);

    let (_, contents) = res.contents.split_once("\ndeclare_with_version! { DEPRECATED").unwrap();
    let (deprecated_src, contents) = contents.split_once("\n]}").unwrap();
    res.deprecated_end = (res.contents.len() - contents.len() - 2) as u32;

    let (_, contents) = contents.split_once("\ndeclare_with_version! { RENAMED").unwrap();
    let (renamed_src, contents) = contents.split_once("\n]}").unwrap();
    res.renamed_end = (res.contents.len() - contents.len() - 2) as u32;

    for line in deprecated_src.lines() {
        let mut offset = 0usize;
        let mut iter = tokenize(line).map(|t| {
            let range = offset..offset + t.len as usize;
            offset = range.end;

            LintDeclSearchResult {
                token_kind: t.kind,
                content: &line[range.clone()],
                range,
            }
        });

        let (name, reason) = match_tokens!(
            iter,
            // ("old_name",
            Whitespace OpenParen Literal{kind: LiteralKind::Str{..},..}(name) Comma
            // "new_name"),
            Whitespace Literal{kind: LiteralKind::Str{..},..}(reason) CloseParen Comma
        );
        res.deprecated.push(DeprecatedLint::new(name, reason));
    }
    for line in renamed_src.lines() {
        let mut offset = 0usize;
        let mut iter = tokenize(line).map(|t| {
            let range = offset..offset + t.len as usize;
            offset = range.end;

            LintDeclSearchResult {
                token_kind: t.kind,
                content: &line[range.clone()],
                range,
            }
        });

        let (old_name, new_name) = match_tokens!(
            iter,
            // ("old_name",
            Whitespace OpenParen Literal{kind: LiteralKind::Str{..},..}(old_name) Comma
            // "new_name"),
            Whitespace Literal{kind: LiteralKind::Str{..},..}(new_name) CloseParen Comma
        );
        res.renamed.push(RenamedLint::new(old_name, new_name));
    }

    res
}

/// Removes the line splices and surrounding quotes from a string literal
fn remove_line_splices(s: &str) -> String {
    let s = s
        .strip_prefix('r')
        .unwrap_or(s)
        .trim_matches('#')
        .strip_prefix('"')
        .and_then(|s| s.strip_suffix('"'))
        .unwrap_or_else(|| panic!("expected quoted string, found `{s}`"));
    let mut res = String::with_capacity(s.len());
    unescape_unicode(s, Mode::Str, &mut |range, ch| {
        if ch.is_ok() {
            res.push_str(&s[range]);
        }
    });
    res
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_clippy_lint_decls() {
        static CONTENTS: &str = r#"
            declare_clippy_lint! {
                #[clippy::version = "Hello Clippy!"]
                pub PTR_ARG,
                style,
                "really long \
                text"
            }

            declare_clippy_lint!{
                #[clippy::version = "Test version"]
                pub DOC_MARKDOWN,
                pedantic,
                "single line"
            }
        "#;
        let mut result = Vec::new();
        parse_clippy_lint_decls(CONTENTS, "module_name", &mut result);
        for r in &mut result {
            r.declaration_range = Range::default();
        }

        let expected = vec![
            Lint::new(
                "ptr_arg",
                "style",
                "\"really long text\"",
                "module_name",
                Range::default(),
            ),
            Lint::new(
                "doc_markdown",
                "pedantic",
                "\"single line\"",
                "module_name",
                Range::default(),
            ),
        ];
        assert_eq!(expected, result);
    }

    #[test]
    fn test_by_lint_group() {
        let lints = vec![
            Lint::new("should_assert_eq", "group1", "\"abc\"", "module_name", Range::default()),
            Lint::new(
                "should_assert_eq2",
                "group2",
                "\"abc\"",
                "module_name",
                Range::default(),
            ),
            Lint::new("incorrect_match", "group1", "\"abc\"", "module_name", Range::default()),
        ];
        let mut expected: HashMap<String, Vec<Lint>> = HashMap::new();
        expected.insert(
            "group1".to_string(),
            vec![
                Lint::new("should_assert_eq", "group1", "\"abc\"", "module_name", Range::default()),
                Lint::new("incorrect_match", "group1", "\"abc\"", "module_name", Range::default()),
            ],
        );
        expected.insert(
            "group2".to_string(),
            vec![Lint::new(
                "should_assert_eq2",
                "group2",
                "\"abc\"",
                "module_name",
                Range::default(),
            )],
        );
        assert_eq!(expected, Lint::by_lint_group(lints.into_iter()));
    }
}
