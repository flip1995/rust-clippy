use crate::utils::{UpdateMode, exit_with_failure, replace_region_in_file};
use itertools::Itertools;
use rustc_lexer::{LiteralKind, TokenKind, tokenize};
use rustc_literal_escaper::{Mode, unescape_unicode};
use std::collections::{HashMap, HashSet};
use std::ffi::OsStr;
use std::fmt::{self, Write};
use std::fs;
use std::ops::Range;
use std::path::Path;
use walkdir::{DirEntry, WalkDir};

const GENERATED_FILE_COMMENT: &str = "// This file was generated by `cargo dev update_lints`.\n\
     // Use that command to update this file and do not edit by hand.\n\
     // Manual edits will be overwritten.\n\n";

const DOCS_LINK: &str = "https://rust-lang.github.io/rust-clippy/master/index.html";

/// Runs the `update_lints` command.
///
/// This updates various generated values from the lint source code.
///
/// `update_mode` indicates if the files should be updated or if updates should be checked for.
///
/// # Panics
///
/// Panics if a file path could not read from or then written to
pub fn update(update_mode: UpdateMode) {
    let (lints, deprecated_lints, renamed_lints) = gather_all();
    generate_lint_files(update_mode, &lints, &deprecated_lints, &renamed_lints);
}

pub fn generate_lint_files(
    update_mode: UpdateMode,
    lints: &[Lint],
    deprecated_lints: &[DeprecatedLint],
    renamed_lints: &[RenamedLint],
) {
    let mut lints = lints.to_owned();
    lints.sort_by_key(|lint| lint.name.clone());

    replace_region_in_file(
        update_mode,
        Path::new("README.md"),
        "[There are over ",
        " lints included in this crate!]",
        |res| {
            write!(res, "{}", round_to_fifty(lints.len())).unwrap();
        },
    );

    replace_region_in_file(
        update_mode,
        Path::new("book/src/README.md"),
        "[There are over ",
        " lints included in this crate!]",
        |res| {
            write!(res, "{}", round_to_fifty(lints.len())).unwrap();
        },
    );

    replace_region_in_file(
        update_mode,
        Path::new("CHANGELOG.md"),
        "<!-- begin autogenerated links to lint list -->\n",
        "<!-- end autogenerated links to lint list -->",
        |res| {
            for lint in lints
                .iter()
                .map(|l| &*l.name)
                .chain(deprecated_lints.iter().filter_map(|l| l.name.strip_prefix("clippy::")))
                .chain(renamed_lints.iter().filter_map(|l| l.old_name.strip_prefix("clippy::")))
                .sorted()
            {
                writeln!(res, "[`{lint}`]: {DOCS_LINK}#{lint}").unwrap();
            }
        },
    );

    // This has to be in lib.rs, otherwise rustfmt doesn't work
    replace_region_in_file(
        update_mode,
        Path::new("clippy_lints/src/lib.rs"),
        "// begin lints modules, do not remove this comment, it’s used in `update_lints`\n",
        "// end lints modules, do not remove this comment, it’s used in `update_lints`",
        |res| {
            for lint_mod in lints.iter().map(|l| &l.module).unique().sorted() {
                writeln!(res, "mod {lint_mod};").unwrap();
            }
        },
    );

    process_file(
        "clippy_lints/src/declared_lints.rs",
        update_mode,
        &gen_declared_lints(lints.iter()),
    );

    let content = gen_deprecated_lints_test(deprecated_lints);
    process_file("tests/ui/deprecated.rs", update_mode, &content);

    let content = gen_renamed_lints_test(renamed_lints);
    process_file("tests/ui/rename.rs", update_mode, &content);
}

pub fn print_lints() {
    let (lints, _, _) = gather_all();
    let lint_count = lints.len();
    let grouped_by_lint_group = Lint::by_lint_group(lints.into_iter());

    for (lint_group, mut lints) in grouped_by_lint_group {
        println!("\n## {lint_group}");

        lints.sort_by_key(|l| l.name.clone());

        for lint in lints {
            println!("* [{}]({DOCS_LINK}#{}) ({})", lint.name, lint.name, lint.desc);
        }
    }

    println!("there are {lint_count} lints");
}

fn round_to_fifty(count: usize) -> usize {
    count / 50 * 50
}

fn process_file(path: impl AsRef<Path>, update_mode: UpdateMode, content: &str) {
    if update_mode == UpdateMode::Check {
        let old_content =
            fs::read_to_string(&path).unwrap_or_else(|e| panic!("Cannot read from {}: {e}", path.as_ref().display()));
        if content != old_content {
            exit_with_failure();
        }
    } else {
        fs::write(&path, content.as_bytes())
            .unwrap_or_else(|e| panic!("Cannot write to {}: {e}", path.as_ref().display()));
    }
}

/// Lint data parsed from the Clippy source code.
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct Lint {
    pub name: String,
    pub group: String,
    pub desc: String,
    pub module: String,
    pub declaration_range: Range<usize>,
}

impl Lint {
    #[must_use]
    fn new(name: &str, group: &str, desc: &str, module: &str, declaration_range: Range<usize>) -> Self {
        Self {
            name: name.to_lowercase(),
            group: group.into(),
            desc: remove_line_splices(desc),
            module: module.into(),
            declaration_range,
        }
    }

    /// Returns the lints in a `HashMap`, grouped by the different lint groups
    #[must_use]
    fn by_lint_group(lints: impl Iterator<Item = Self>) -> HashMap<String, Vec<Self>> {
        lints.map(|lint| (lint.group.to_string(), lint)).into_group_map()
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct DeprecatedLint {
    pub name: String,
    pub reason: String,
}
impl DeprecatedLint {
    fn new(name: &str, reason: &str) -> Self {
        Self {
            name: remove_line_splices(name),
            reason: remove_line_splices(reason),
        }
    }
}

pub struct RenamedLint {
    pub old_name: String,
    pub new_name: String,
}
impl RenamedLint {
    fn new(old_name: &str, new_name: &str) -> Self {
        Self {
            old_name: remove_line_splices(old_name),
            new_name: remove_line_splices(new_name),
        }
    }
}

/// Generates the code for registering lints
#[must_use]
fn gen_declared_lints<'a>(lints: impl Iterator<Item = &'a Lint>) -> String {
    let mut details: Vec<_> = lints.map(|l| (&l.module, l.name.to_uppercase())).collect();
    details.sort_unstable();

    let mut output = GENERATED_FILE_COMMENT.to_string();
    output.push_str("pub static LINTS: &[&crate::LintInfo] = &[\n");

    for (module_name, lint_name) in details {
        let _: fmt::Result = writeln!(output, "    crate::{module_name}::{lint_name}_INFO,");
    }
    output.push_str("];\n");

    output
}

fn gen_deprecated_lints_test(lints: &[DeprecatedLint]) -> String {
    let mut res: String = GENERATED_FILE_COMMENT.into();
    for lint in lints {
        writeln!(res, "#![warn({})] //~ ERROR: lint `{}`", lint.name, lint.name).unwrap();
    }
    res.push_str("\nfn main() {}\n");
    res
}

#[must_use]
pub fn gen_renamed_lints_test(lints: &[RenamedLint]) -> String {
    let mut seen_lints = HashSet::new();
    let mut res: String = GENERATED_FILE_COMMENT.into();

    res.push_str("#![allow(clippy::duplicated_attributes)]\n");
    for lint in lints {
        if seen_lints.insert(&lint.new_name) {
            writeln!(res, "#![allow({})]", lint.new_name).unwrap();
        }
    }
    seen_lints.clear();
    for lint in lints {
        if seen_lints.insert(&lint.old_name) {
            writeln!(res, "#![warn({})] //~ ERROR: lint `{}`", lint.old_name, lint.old_name).unwrap();
        }
    }
    res.push_str("\nfn main() {}\n");
    res
}

/// Gathers all lints defined in `clippy_lints/src`
#[must_use]
pub fn gather_all() -> (Vec<Lint>, Vec<DeprecatedLint>, Vec<RenamedLint>) {
    let mut lints = Vec::with_capacity(1000);
    let mut deprecated_lints = Vec::with_capacity(50);
    let mut renamed_lints = Vec::with_capacity(50);

    for file in clippy_lints_src_files() {
        let path = file.path();
        let contents =
            fs::read_to_string(path).unwrap_or_else(|e| panic!("Cannot read from `{}`: {e}", path.display()));
        let module = path.as_os_str().to_str().unwrap()["clippy_lints/src/".len()..].replace(['/', '\\'], "::");

        // If the lints are stored in mod.rs, we get the module name from
        // the containing directory:
        let module = if let Some(module) = module.strip_suffix("::mod.rs") {
            module
        } else {
            module.strip_suffix(".rs").unwrap_or(&module)
        };

        if module == "deprecated_lints" {
            parse_deprecated_contents(&contents, &mut deprecated_lints, &mut renamed_lints);
        } else {
            parse_contents(&contents, module, &mut lints);
        }
    }
    (lints, deprecated_lints, renamed_lints)
}

pub fn clippy_lints_src_files() -> impl Iterator<Item = DirEntry> {
    let iter = WalkDir::new("clippy_lints/src").into_iter();
    iter.map(Result::unwrap)
        .filter(|f| f.path().extension() == Some(OsStr::new("rs")))
}

macro_rules! match_tokens {
    ($iter:ident, $($token:ident $({$($fields:tt)*})? $(($capture:ident))?)*) => {
         {
            $(#[allow(clippy::redundant_pattern)] let Some(LintDeclSearchResult {
                    token_kind: TokenKind::$token $({$($fields)*})?,
                    content: $($capture @)? _,
                    ..
            }) = $iter.next() else {
                continue;
            };)*
            #[allow(clippy::unused_unit)]
            { ($($($capture,)?)*) }
        }
    }
}

pub(crate) use match_tokens;

pub(crate) struct LintDeclSearchResult<'a> {
    pub token_kind: TokenKind,
    pub content: &'a str,
    pub range: Range<usize>,
}

/// Parse a source file looking for `declare_clippy_lint` macro invocations.
fn parse_contents(contents: &str, module: &str, lints: &mut Vec<Lint>) {
    let mut offset = 0usize;
    let mut iter = tokenize(contents).map(|t| {
        let range = offset..offset + t.len as usize;
        offset = range.end;

        LintDeclSearchResult {
            token_kind: t.kind,
            content: &contents[range.clone()],
            range,
        }
    });

    while let Some(LintDeclSearchResult { range, .. }) = iter.find(
        |LintDeclSearchResult {
             token_kind, content, ..
         }| token_kind == &TokenKind::Ident && *content == "declare_clippy_lint",
    ) {
        let start = range.start;
        let mut iter = iter
            .by_ref()
            .filter(|t| !matches!(t.token_kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));
        // matches `!{`
        match_tokens!(iter, Bang OpenBrace);
        match iter.next() {
            // #[clippy::version = "version"] pub
            Some(LintDeclSearchResult {
                token_kind: TokenKind::Pound,
                ..
            }) => {
                match_tokens!(iter, OpenBracket Ident Colon Colon Ident Eq Literal{..} CloseBracket Ident);
            },
            // pub
            Some(LintDeclSearchResult {
                token_kind: TokenKind::Ident,
                ..
            }) => (),
            _ => continue,
        }

        let (name, group, desc) = match_tokens!(
            iter,
            // LINT_NAME
            Ident(name) Comma
            // group,
            Ident(group) Comma
            // "description"
            Literal{..}(desc)
        );

        if let Some(end) = iter.find_map(|t| {
            if let LintDeclSearchResult {
                token_kind: TokenKind::CloseBrace,
                range,
                ..
            } = t
            {
                Some(range.end)
            } else {
                None
            }
        }) {
            lints.push(Lint::new(name, group, desc, module, start..end));
        }
    }
}

/// Parse a source file looking for `declare_deprecated_lint` macro invocations.
fn parse_deprecated_contents(contents: &str, deprecated: &mut Vec<DeprecatedLint>, renamed: &mut Vec<RenamedLint>) {
    let Some((_, contents)) = contents.split_once("\ndeclare_with_version! { DEPRECATED") else {
        return;
    };
    let Some((deprecated_src, renamed_src)) = contents.split_once("\ndeclare_with_version! { RENAMED") else {
        return;
    };

    for line in deprecated_src.lines() {
        let mut offset = 0usize;
        let mut iter = tokenize(line).map(|t| {
            let range = offset..offset + t.len as usize;
            offset = range.end;

            LintDeclSearchResult {
                token_kind: t.kind,
                content: &line[range.clone()],
                range,
            }
        });

        let (name, reason) = match_tokens!(
            iter,
            // ("old_name",
            Whitespace OpenParen Literal{kind: LiteralKind::Str{..},..}(name) Comma
            // "new_name"),
            Whitespace Literal{kind: LiteralKind::Str{..},..}(reason) CloseParen Comma
        );
        deprecated.push(DeprecatedLint::new(name, reason));
    }
    for line in renamed_src.lines() {
        let mut offset = 0usize;
        let mut iter = tokenize(line).map(|t| {
            let range = offset..offset + t.len as usize;
            offset = range.end;

            LintDeclSearchResult {
                token_kind: t.kind,
                content: &line[range.clone()],
                range,
            }
        });

        let (old_name, new_name) = match_tokens!(
            iter,
            // ("old_name",
            Whitespace OpenParen Literal{kind: LiteralKind::Str{..},..}(old_name) Comma
            // "new_name"),
            Whitespace Literal{kind: LiteralKind::Str{..},..}(new_name) CloseParen Comma
        );
        renamed.push(RenamedLint::new(old_name, new_name));
    }
}

/// Removes the line splices and surrounding quotes from a string literal
fn remove_line_splices(s: &str) -> String {
    let s = s
        .strip_prefix('r')
        .unwrap_or(s)
        .trim_matches('#')
        .strip_prefix('"')
        .and_then(|s| s.strip_suffix('"'))
        .unwrap_or_else(|| panic!("expected quoted string, found `{s}`"));
    let mut res = String::with_capacity(s.len());
    unescape_unicode(s, Mode::Str, &mut |range, ch| {
        if ch.is_ok() {
            res.push_str(&s[range]);
        }
    });
    res
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_contents() {
        static CONTENTS: &str = r#"
            declare_clippy_lint! {
                #[clippy::version = "Hello Clippy!"]
                pub PTR_ARG,
                style,
                "really long \
                text"
            }

            declare_clippy_lint!{
                #[clippy::version = "Test version"]
                pub DOC_MARKDOWN,
                pedantic,
                "single line"
            }
        "#;
        let mut result = Vec::new();
        parse_contents(CONTENTS, "module_name", &mut result);
        for r in &mut result {
            r.declaration_range = Range::default();
        }

        let expected = vec![
            Lint::new(
                "ptr_arg",
                "style",
                "\"really long text\"",
                "module_name",
                Range::default(),
            ),
            Lint::new(
                "doc_markdown",
                "pedantic",
                "\"single line\"",
                "module_name",
                Range::default(),
            ),
        ];
        assert_eq!(expected, result);
    }

    #[test]
    fn test_by_lint_group() {
        let lints = vec![
            Lint::new("should_assert_eq", "group1", "\"abc\"", "module_name", Range::default()),
            Lint::new(
                "should_assert_eq2",
                "group2",
                "\"abc\"",
                "module_name",
                Range::default(),
            ),
            Lint::new("incorrect_match", "group1", "\"abc\"", "module_name", Range::default()),
        ];
        let mut expected: HashMap<String, Vec<Lint>> = HashMap::new();
        expected.insert(
            "group1".to_string(),
            vec![
                Lint::new("should_assert_eq", "group1", "\"abc\"", "module_name", Range::default()),
                Lint::new("incorrect_match", "group1", "\"abc\"", "module_name", Range::default()),
            ],
        );
        expected.insert(
            "group2".to_string(),
            vec![Lint::new(
                "should_assert_eq2",
                "group2",
                "\"abc\"",
                "module_name",
                Range::default(),
            )],
        );
        assert_eq!(expected, Lint::by_lint_group(lints.into_iter()));
    }
}
